<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NYC Photo Guide</title>
    <style>
        /* CSS Variables for themes */
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --text-muted: #adb5bd;
            --border-color: #dee2e6;
            --accent-color: #007bff;
            --accent-hover: #0056b3;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --info-color: #17a2b8;
        }

        [data-theme="dark"] {
            --bg-primary: #212529;
            --bg-secondary: #343a40;
            --bg-tertiary: #495057;
            --text-primary: #f8f9fa;
            --text-secondary: #adb5bd;
            --text-muted: #6c757d;
            --border-color: #495057;
            --accent-color: #0d6efd;
            --accent-hover: #0b5ed7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        /* Layout */
        .app-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem;
        }

        .header-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-group label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .main-content {
            display: flex;
            flex: 1;
            gap: 1rem;
            padding: 1rem;
        }

        .left-sidebar {
            width: 300px;
            flex-shrink: 0;
        }

        .content-area {
            flex: 1;
            display: flex;
            gap: 1rem;
        }

        .locations-list {
            flex: 1;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .map-container {
            width: 400px;
            height: calc(100vh - 200px);
            position: sticky;
            top: 150px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }

        /* Light/Moon Panels */
        .light-panel {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .light-panel h3 {
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .light-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .light-time {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
        }

        /* Location Cards */
        .location-section {
            margin-bottom: 2rem;
        }

        .section-header {
            background-color: var(--bg-secondary);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-weight: bold;
            color: var(--text-primary);
        }

        .location-card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .card-header {
            padding: 1rem;
            cursor: pointer;
            user-select: none;
        }

        .card-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .card-title h4 {
            flex: 1;
            color: var(--text-primary);
        }

        .rank-badge {
            background-color: var(--accent-color);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .block-badge {
            background-color: var(--info-color);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .card-summary {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .card-content {
            display: none;
            padding: 0 1rem 1rem;
        }

        .card-content.expanded {
            display: block;
        }

        .card-row {
            display: flex;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }

        .card-row-label {
            min-width: 100px;
            font-weight: bold;
            color: var(--text-secondary);
        }

        .card-row-value {
            flex: 1;
            color: var(--text-primary);
        }

        .card-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .btn {
            padding: 0.375rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.875rem;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: all 0.2s;
        }

        .btn:hover {
            background-color: var(--bg-tertiary);
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .btn-primary:hover {
            background-color: var(--accent-hover);
            border-color: var(--accent-hover);
        }

        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
        }

        /* Pills */
        .pills {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 0.5rem 0;
        }

        .pill {
            padding: 0.25rem 0.5rem;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pill:hover {
            background-color: var(--accent-color);
            color: white;
        }

        .pill.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        /* Form Elements */
        .form-control {
            padding: 0.375rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        input[type="checkbox"] {
            accent-color: var(--accent-color);
        }

        input[type="range"] {
            accent-color: var(--accent-color);
        }

        /* Map */
        #map {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        .map-tabs {
            display: flex;
            margin-bottom: 0.5rem;
        }

        .map-tab {
            flex: 1;
            padding: 0.5rem;
            text-align: center;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            font-size: 0.875rem;
        }

        .map-tab.active {
            background-color: var(--accent-color);
            color: white;
        }

        .map-tab:first-child {
            border-top-left-radius: 4px;
            border-bottom-left-radius: 4px;
        }

        .map-tab:last-child {
            border-top-right-radius: 4px;
            border-bottom-right-radius: 4px;
            border-left: none;
        }

        /* Details sections */
        .details-section {
            margin: 1rem 0;
            padding: 1rem;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .details-section h5 {
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .detail-item {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background-color: var(--bg-secondary);
            border-radius: 4px;
        }

        .detail-title {
            font-weight: bold;
            color: var(--text-primary);
        }

        .detail-content {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        /* Loading and error states */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            color: var(--text-secondary);
        }

        .error {
            color: var(--danger-color);
            padding: 1rem;
            background-color: rgba(220, 53, 69, 0.1);
            border-radius: 4px;
            margin: 1rem 0;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-content {
                flex-direction: column;
            }

            .content-area {
                flex-direction: column;
            }

            .map-container {
                width: 100%;
                height: 400px;
                position: static;
            }

            .left-sidebar {
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                justify-content: space-between;
            }

            .main-content {
                padding: 0.5rem;
            }
        }

        /* Image gallery */
        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .gallery-image {
            width: 100%;
            height: 100px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Utility classes */
        .text-center { text-align: center; }
        .text-muted { color: var(--text-muted); }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-3 { margin-bottom: 1rem; }
        .hidden { display: none; }
        .visible { display: block; }

        /* Toast notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            max-width: 300px;
            z-index: 1050;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .toast.success {
            border-color: var(--success-color);
            background-color: rgba(40, 167, 69, 0.1);
        }

        .toast.error {
            border-color: var(--danger-color);
            background-color: rgba(220, 53, 69, 0.1);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1 class="header-title">NYC Photo Guide</h1>
            <div class="controls">
                <div class="control-group">
                    <label for="dayA">Day A:</label>
                    <input type="date" id="dayA" class="form-control" value="2025-10-03">
                </div>
                <div class="control-group">
                    <label for="dayB">Day B:</label>
                    <input type="date" id="dayB" class="form-control" value="2025-10-04">
                </div>
                <div class="control-group">
                    <label><input type="checkbox" id="showFriSat" checked> Fri/Sat</label>
                </div>
                <div class="control-group">
                    <label><input type="checkbox" id="showMorning" checked> Morning</label>
                    <label><input type="checkbox" id="showAfternoon" checked> Afternoon</label>
                    <label><input type="checkbox" id="showEvening" checked> Evening</label>
                    <label><input type="checkbox" id="showNight" checked> Night</label>
                </div>
                <div class="control-group">
                    <label for="rankRange">Rank:</label>
                    <input type="range" id="rankMin" min="1" max="5" value="1" class="form-control">
                    <span id="rankMinValue">1</span>
                    <input type="range" id="rankMax" min="1" max="5" value="5" class="form-control">
                    <span id="rankMaxValue">5</span>
                </div>
                <div class="control-group">
                    <input type="text" id="searchInput" placeholder="Search locations..." class="form-control">
                </div>
                <div class="control-group">
                    <button class="btn" id="expandAll">Expand All</button>
                    <button class="btn" id="collapseAll">Collapse All</button>
                    <button class="btn" id="exportCSV">Export CSV</button>
                    <button class="btn" id="exportKML">Export KML</button>
                    <button class="btn" id="exportJSON">Export JSON</button>
                    <button class="btn" id="importJSON">Import JSON</button>
                    <input type="file" id="importFile" accept=".json" class="hidden">
                    <button class="btn" id="themeToggle">🌙</button>
                </div>
            </div>
        </header>

        <main class="main-content">
            <aside class="left-sidebar">
                <div id="lightPanels"></div>
            </aside>

            <div class="content-area">
                <section class="locations-list" id="locationsList">
                    <!-- Location cards will be populated here -->
                </section>

                <aside class="map-container">
                    <div class="map-tabs">
                        <div class="map-tab active" id="googleTab">Google Maps</div>
                        <div class="map-tab" id="leafletTab">Leaflet (Offline)</div>
                    </div>
                    <div id="map"></div>
                </aside>
            </div>
        </main>
    </div>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- External Scripts -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.js"></script>

    <script type="module">
        // Application Configuration
        const CONFIG = {
            GOOGLE_MAPS_API_KEY: 'AIzaSyDsq2ztFeFfmgqiRIZZtK5R7aCVGF66-80',
            NOAA_TIDES_STATION: '8518750', // The Battery
            DEFAULT_CENTER: { lat: 40.7128, lng: -73.9960 }, // NYC
            DEFAULT_ZOOM: 12,
            PLACES_PHOTO_LIMIT: 12
        };

        // Location Data
        const LOCATIONS_DATA = [
            {
                "id": "dumbo_washington_water_manhattan_bridge_keyhole",
                "name": "DUMBO — Washington & Water (Manhattan Bridge Keyhole)",
                "day": "2025-10-03",
                "block": "Morning",
                "rank": 1,
                "bearing": "NNE toward Manhattan Bridge/ESB",
                "whyNow": "Arrive pre‑dawn; classic ESB-in-arch alignment.",
                "gear": "24–70mm; CPL/ND",
                "settings": "Arrive 30–60 min before sunrise; handheld 1/250s+ @ f/5.6–8, ISO 100–400.",
                "activeAnchor": 0,
                "anchors": [
                    {
                        "label": "Main view",
                        "lat": 40.7034225,
                        "lon": -73.9893714
                    }
                ],
                "micro": [
                    {
                        "title": "Centerline",
                        "r": 0.0,
                        "bearing": 22.5,
                        "dir": "",
                        "detail": "Main alignment from anchor."
                    },
                    {
                        "title": "Step‑back",
                        "r": 10.0,
                        "bearing": 22.5,
                        "dir": "",
                        "detail": "Step back ~10 m; arrow still toward subject."
                    },
                    {
                        "title": "Corner curb",
                        "r": 22.0,
                        "bearing": 22.5,
                        "dir": "",
                        "detail": "Diagonal curb vantage; arrow toward subject."
                    }
                ],
                "pins": [
                    {
                        "title": "Parking gap watch",
                        "detail": "Scan for a temporary gap to remove parked cars; be ready to shoot quickly."
                    },
                    {
                        "title": "Reflections after wash",
                        "detail": "Street or lawn irrigation leaves sheen—use CPL to control glare."
                    },
                    {
                        "title": "Taxi or jogger streaks",
                        "detail": "If traffic begins, try 1/8–1/2s for motion streaks."
                    }
                ],
                "shots": [
                    {
                        "title": "Establishing wide (16–24mm)",
                        "detail": "Include context and sky color; keep verticals straight."
                    },
                    {
                        "title": "Low angle leading lines",
                        "detail": "Camera close to ground; emphasize texture or rails."
                    },
                    {
                        "title": "Human scale",
                        "detail": "Single figure walking/running; time the stride."
                    },
                    {
                        "title": "Compressed crop (50/70mm)",
                        "detail": "Use longer end for a clean graphic frame; crop if needed."
                    },
                    {
                        "title": "Detail cutaway",
                        "detail": "Reflections, signage, patterns that summarize place."
                    }
                ]
            },
            {
                "id": "top_of_the_rock_observation_deck",
                "name": "Top of the Rock — Observation Deck",
                "day": "2025-10-03",
                "block": "Evening",
                "rank": 1,
                "bearing": "W & S (sunset, ESB)",
                "whyNow": "Arrive 60–90 min pre‑sunset; no tripods on deck.",
                "gear": "16–24mm; 24–70mm; cloth",
                "settings": "Blue-hour blend; 1/60–1s @ f/5.6–8, ISO 100–800; bracketing if needed.",
                "activeAnchor": 0,
                "anchors": [
                    {
                        "label": "Main view",
                        "lat": 40.7591,
                        "lon": -73.9795
                    }
                ],
                "micro": [
                    {
                        "title": "Centerline",
                        "r": 0.0,
                        "bearing": 270,
                        "dir": "",
                        "detail": "Main alignment from anchor."
                    },
                    {
                        "title": "Step‑back",
                        "r": 10.0,
                        "bearing": 270,
                        "dir": "",
                        "detail": "Step back ~10 m; arrow still toward subject."
                    }
                ],
                "pins": [
                    {
                        "title": "Blue-hour reflections",
                        "detail": "Arrive 45–75 min before sunset; water calms near high tide."
                    },
                    {
                        "title": "Silhouette walkers",
                        "detail": "Expose for sky; use crosswalks as a stage."
                    }
                ],
                "shots": [
                    {
                        "title": "Blue-hour skyline (16–24mm)",
                        "detail": "Balance ambient & city lights; 10–20 min after sunset."
                    },
                    {
                        "title": "Silhouette frame (35/50mm)",
                        "detail": "Backlight against sky/water; faster shutter."
                    },
                    {
                        "title": "Detail twinkle",
                        "detail": "Tight crop on lights/signs; sparkle highlights."
                    }
                ]
            },
            {
                "id": "times_square_duffy_square",
                "name": "Times Square — Duffy Square",
                "day": "2025-10-03",
                "block": "Night",
                "rank": 1,
                "bearing": "Broadway & 7th Ave",
                "whyNow": "Neon people blur 4–10s; portraits at f/1.8–2.8.",
                "gear": "24–70mm; fast 50mm; mini‑tripod",
                "settings": "Tripod: 1–10s @ f/6.3–8, ISO 100–400; expose for highlights.",
                "activeAnchor": 0,
                "anchors": [
                    {
                        "label": "Main view",
                        "lat": 40.758,
                        "lon": -73.9855
                    }
                ],
                "micro": [
                    {
                        "title": "Centerline",
                        "r": 0.0,
                        "bearing": 0.0,
                        "dir": "",
                        "detail": "Main alignment from anchor."
                    }
                ],
                "pins": [
                    {
                        "title": "Clean tripod placement",
                        "detail": "Stay behind safety lines; avoid blocking paths."
                    },
                    {
                        "title": "Neon trails",
                        "detail": "1–4s exposures; wait for buses to paint the frame."
                    }
                ],
                "shots": [
                    {
                        "title": "Long exposure base (16–24mm)",
                        "detail": "1–10s; shoot 10–20 frames; pick best trails."
                    },
                    {
                        "title": "People blur (1–2s)",
                        "detail": "Trace flows of commuters without losing structure."
                    }
                ]
            },
            {
                "id": "bethesda_terrace_arcade",
                "name": "Bethesda Terrace — Arcade",
                "day": "2025-10-04",
                "block": "Morning",
                "rank": 1,
                "bearing": "N/S arcade axis",
                "whyNow": "Start at civil dawn; vanishing arches + warm side‑light.",
                "gear": "24–70mm; fast 35mm",
                "settings": "Arrive 30–60 min before sunrise; handheld 1/250s+ @ f/5.6–8, ISO 100–400.",
                "activeAnchor": 0,
                "anchors": [
                    {
                        "label": "Main view",
                        "lat": 40.7741,
                        "lon": -73.9701
                    }
                ],
                "micro": [
                    {
                        "title": "Centerline",
                        "r": 0.0,
                        "bearing": 0,
                        "dir": "",
                        "detail": "Main alignment from anchor."
                    }
                ],
                "pins": [
                    {
                        "title": "Shadow geometry",
                        "detail": "Look for repeating cast-iron, stoops, or rails to form patterns."
                    }
                ],
                "shots": [
                    {
                        "title": "Establishing wide (16–24mm)",
                        "detail": "Include context and sky color; keep verticals straight."
                    },
                    {
                        "title": "Detail cutaway",
                        "detail": "Reflections, signage, patterns that summarize place."
                    }
                ]
            }
        ];

        // Application State
        class AppState {
            constructor() {
                this.locations = [...LOCATIONS_DATA];
                this.filteredLocations = [...LOCATIONS_DATA];
                this.expandedCards = new Set();
                this.currentMapMode = 'google';
                this.map = null;
                this.markers = [];
                this.currentTheme = localStorage.getItem('theme') || 'light';
                this.userLocation = null;
                this.routes = new Map();

                this.filters = {
                    dayA: '2025-10-03',
                    dayB: '2025-10-04',
                    showFriSat: true,
                    blocks: {
                        Morning: true,
                        Afternoon: true,
                        Evening: true,
                        Night: true
                    },
                    rankMin: 1,
                    rankMax: 5,
                    search: ''
                };

                this.initializeTheme();
            }

            initializeTheme() {
                document.documentElement.setAttribute('data-theme', this.currentTheme);
                const themeToggle = document.getElementById('themeToggle');
                if (themeToggle) {
                    themeToggle.textContent = this.currentTheme === 'light' ? '🌙' : '☀️';
                }
            }

            toggleTheme() {
                this.currentTheme = this.currentTheme === 'light' ? 'dark' : 'light';
                document.documentElement.setAttribute('data-theme', this.currentTheme);
                localStorage.setItem('theme', this.currentTheme);
                const themeToggle = document.getElementById('themeToggle');
                if (themeToggle) {
                    themeToggle.textContent = this.currentTheme === 'light' ? '🌙' : '☀️';
                }
            }

            updateFilters() {
                this.filteredLocations = this.locations.filter(location => {
                    // Day filter
                    const matchesDay = location.day === this.filters.dayA || location.day === this.filters.dayB;
                    
                    // Block filter
                    const matchesBlock = this.filters.blocks[location.block];
                    
                    // Rank filter
                    const matchesRank = location.rank >= this.filters.rankMin && location.rank <= this.filters.rankMax;
                    
                    // Search filter
                    const matchesSearch = this.filters.search === '' || 
                        location.name.toLowerCase().includes(this.filters.search.toLowerCase()) ||
                        location.whyNow.toLowerCase().includes(this.filters.search.toLowerCase()) ||
                        location.gear.toLowerCase().includes(this.filters.search.toLowerCase()) ||
                        location.pins.some(pin => pin.title.toLowerCase().includes(this.filters.search.toLowerCase()) ||
                                              pin.detail.toLowerCase().includes(this.filters.search.toLowerCase())) ||
                        location.shots.some(shot => shot.title.toLowerCase().includes(this.filters.search.toLowerCase()) ||
                                               shot.detail.toLowerCase().includes(this.filters.search.toLowerCase()));

                    return matchesDay && matchesBlock && matchesRank && matchesSearch;
                });
                
                this.render();
            }

            render() {
                this.renderLocationsList();
                this.renderLightPanels();
                this.updateMap();
            }

            renderLocationsList() {
                const container = document.getElementById('locationsList');
                if (!container) return;

                // Group locations by day and block
                const grouped = {};
                this.filteredLocations.forEach(location => {
                    const key = `${location.day} - ${location.block}`;
                    if (!grouped[key]) {
                        grouped[key] = [];
                    }
                    grouped[key].push(location);
                });

                // Sort locations within each group by rank
                Object.values(grouped).forEach(group => {
                    group.sort((a, b) => a.rank - b.rank);
                });

                let html = '';
                Object.entries(grouped).forEach(([key, locations]) => {
                    html += `<div class="location-section">`;
                    html += `<div class="section-header">${key}</div>`;
                    
                    locations.forEach(location => {
                        const isExpanded = this.expandedCards.has(location.id);
                        html += this.renderLocationCard(location, isExpanded);
                    });
                    
                    html += `</div>`;
                });

                container.innerHTML = html;
                this.attachCardListeners();
            }

            renderLocationCard(location, isExpanded) {
                const anchor = location.anchors[location.activeAnchor] || location.anchors[0];
                const blockColors = {
                    Morning: '#28a745',
                    Afternoon: '#ffc107',
                    Evening: '#fd7e14',
                    Night: '#6f42c1'
                };

                return `
                    <div class="location-card" data-location-id="${location.id}">
                        <div class="card-header" onclick="app.toggleCard('${location.id}')">
                            <div class="card-title">
                                <h4>${location.name}</h4>
                                <span class="rank-badge">#${location.rank}</span>
                                <span class="block-badge" style="background-color: ${blockColors[location.block]}">${location.block}</span>
                            </div>
                            <div class="card-summary">
                                ${location.day} • ${location.block} • ${location.bearing}
                            </div>
                        </div>
                        <div class="card-content ${isExpanded ? 'expanded' : ''}">
                            <div class="card-row">
                                <span class="card-row-label">Why now:</span>
                                <span class="card-row-value">${location.whyNow}</span>
                            </div>
                            <div class="card-row">
                                <span class="card-row-label">Face & light:</span>
                                <span class="card-row-value">${location.bearing}</span>
                            </div>
                            <div class="card-row">
                                <span class="card-row-label">Gear:</span>
                                <span class="card-row-value">${location.gear}</span>
                            </div>
                            <div class="card-actions">
                                <button class="btn btn-primary" onclick="app.showOnMap('${location.id}')">Show on Map</button>
                                <button class="btn" onclick="app.getETA('${location.id}')">ETA</button>
                                <button class="btn" onclick="app.getRoute('${location.id}')">Route</button>
                                <a href="https://maps.google.com/?q=${anchor.lat},${anchor.lon}" target="_blank" class="btn">Open</a>
                                <a href="https://maps.google.com/maps?daddr=${anchor.lat},${anchor.lon}&dirflg=w" target="_blank" class="btn">Walk to Anchor</a>
                            </div>
                            
                            ${location.anchors.length > 1 ? `
                                <div class="details-section">
                                    <h5>Anchors:</h5>
                                    <div class="pills">
                                        ${location.anchors.map((anc, idx) => `
                                            <span class="pill ${idx === location.activeAnchor ? 'active' : ''}" 
                                                  onclick="app.setActiveAnchor('${location.id}', ${idx})">${anc.label}</span>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                            
                            <div class="details-section">
                                <h5>Micro-pins:</h5>
                                <div class="pills">
                                    ${location.micro.map(micro => `
                                        <a href="https://maps.google.com/maps?daddr=${this.calculateMicroPinPosition(anchor, micro).lat},${this.calculateMicroPinPosition(anchor, micro).lng}&dirflg=w" 
                                           target="_blank" class="pill" title="${micro.detail}">${micro.title}</a>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <div class="details-section">
                                <h5>Pins (Tips):</h5>
                                ${location.pins.map(pin => `
                                    <div class="detail-item">
                                        <div class="detail-title">${pin.title}</div>
                                        <div class="detail-content">${pin.detail}</div>
                                    </div>
                                `).join('')}
                            </div>
                            
                            <div class="details-section">
                                <h5>Shots:</h5>
                                ${location.shots.map(shot => `
                                    <div class="detail-item">
                                        <div class="detail-title">${shot.title}</div>
                                        <div class="detail-content">${shot.detail}</div>
                                    </div>
                                `).join('')}
                            </div>
                            
                            <div class="details-section">
                                <h5>Settings:</h5>
                                <div class="detail-content">${location.settings}</div>
                            </div>
                            
                            <div class="details-section">
                                <h5>NOAA Tides (The Battery):</h5>
                                <div id="tides-${location.id}">
                                    <button class="btn btn-sm" onclick="app.loadTides('${location.id}', '${location.day}')">Load Tide Info</button>
                                </div>
                            </div>
                            
                            <div class="details-section">
                                <h5>Moon Info:</h5>
                                <div id="moon-${location.id}"></div>
                            </div>
                            
                            <div class="details-section">
                                <h5>Address:</h5>
                                <div id="address-${location.id}">
                                    <button class="btn btn-sm" onclick="app.geocodeLocation('${location.id}')">Get Address</button>
                                </div>
                            </div>
                            
                            <div class="details-section">
                                <h5>Reference Images:</h5>
                                <div id="images-${location.id}">
                                    <button class="btn btn-sm" onclick="app.loadPlacesPhotos('${location.id}')">Load Images</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            calculateMicroPinPosition(anchor, micro) {
                const R = 6371000; // Earth's radius in meters
                const bearingRad = micro.bearing * Math.PI / 180;
                const latRad = anchor.lat * Math.PI / 180;
                
                const deltaLat = (micro.r * Math.cos(bearingRad)) / R;
                const deltaLng = (micro.r * Math.sin(bearingRad)) / (R * Math.cos(latRad));
                
                return {
                    lat: anchor.lat + (deltaLat * 180 / Math.PI),
                    lng: anchor.lon + (deltaLng * 180 / Math.PI)
                };
            }

            renderLightPanels() {
                const container = document.getElementById('lightPanels');
                if (!container) return;

                const days = [
                    { date: this.filters.dayA, label: 'Day A' },
                    { date: this.filters.dayB, label: 'Day B' }
                ];

                let html = '';
                days.forEach(day => {
                    const lightInfo = this.calculateLightTimes(new Date(day.date));
                    html += `
                        <div class="light-panel">
                            <h3>${day.label} (${day.date})</h3>
                            <div class="light-info">
                                <div class="light-time">
                                    <span>Civil Dawn:</span>
                                    <span>${lightInfo.civilDawn}</span>
                                </div>
                                <div class="light-time">
                                    <span>Sunrise:</span>
                                    <span>${lightInfo.sunrise}</span>
                                </div>
                                <div class="light-time">
                                    <span>Sunset:</span>
                                    <span>${lightInfo.sunset}</span>
                                </div>
                                <div class="light-time">
                                    <span>Civil Dusk:</span>
                                    <span>${lightInfo.civilDusk}</span>
                                </div>
                                <div class="light-time">
                                    <span>Moonrise:</span>
                                    <span>${lightInfo.moonrise}</span>
                                </div>
                                <div class="light-time">
                                    <span>Moonset:</span>
                                    <span>${lightInfo.moonset}</span>
                                </div>
                                <div class="light-time">
                                    <span>Moon Phase:</span>
                                    <span>${lightInfo.moonPhase}%</span>
                                </div>
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = html;
            }

            calculateLightTimes(date) {
                const times = SunCalc.getTimes(date, CONFIG.DEFAULT_CENTER.lat, CONFIG.DEFAULT_CENTER.lng);
                const moonTimes = SunCalc.getMoonTimes(date, CONFIG.DEFAULT_CENTER.lat, CONFIG.DEFAULT_CENTER.lng);
                const moonIllumination = SunCalc.getMoonIllumination(date);

                return {
                    civilDawn: this.formatTime(times.dawn),
                    sunrise: this.formatTime(times.sunrise),
                    sunset: this.formatTime(times.sunset),
                    civilDusk: this.formatTime(times.dusk),
                    moonrise: moonTimes.rise ? this.formatTime(moonTimes.rise) : 'No rise',
                    moonset: moonTimes.set ? this.formatTime(moonTimes.set) : 'No set',
                    moonPhase: Math.round(moonIllumination.fraction * 100)
                };
            }

            formatTime(date) {
                if (!date || !(date instanceof Date) || isNaN(date)) return 'N/A';
                return date.toLocaleTimeString('en-US', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
            }

            attachCardListeners() {
                // Card listeners are attached via onclick attributes in the HTML
            }

            toggleCard(locationId) {
                if (this.expandedCards.has(locationId)) {
                    this.expandedCards.delete(locationId);
                } else {
                    this.expandedCards.add(locationId);
                }
                this.render();
            }

            expandAllCards() {
                this.filteredLocations.forEach(location => {
                    this.expandedCards.add(location.id);
                });
                this.render();
            }

            collapseAllCards() {
                this.expandedCards.clear();
                this.render();
            }

            setActiveAnchor(locationId, anchorIndex) {
                const location = this.locations.find(loc => loc.id === locationId);
                if (location) {
                    location.activeAnchor = anchorIndex;
                    this.render();
                }
            }

            async loadTides(locationId, date) {
                const tidesContainer = document.getElementById(`tides-${locationId}`);
                if (!tidesContainer) return;

                tidesContainer.innerHTML = '<div class="loading">Loading tides...</div>';

                try {
                    const startDate = new Date(date);
                    const endDate = new Date(date);
                    endDate.setDate(endDate.getDate() + 1);

                    const formatDate = (d) => {
                        const year = d.getFullYear();
                        const month = String(d.getMonth() + 1).padStart(2, '0');
                        const day = String(d.getDate()).padStart(2, '0');
                        return `${year}${month}${day}`;
                    };

                    const url = `https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?product=predictions&begin_date=${formatDate(startDate)}&end_date=${formatDate(endDate)}&datum=MLLW&station=${CONFIG.NOAA_TIDES_STATION}&time_zone=lst_ldt&interval=hilo&units=english&format=json`;

                    const response = await fetch(url);
                    const data = await response.json();

                    if (data.predictions && data.predictions.length > 0) {
                        let html = '<div class="light-info">';
                        data.predictions.forEach(prediction => {
                            html += `
                                <div class="light-time">
                                    <span>${prediction.type === 'H' ? 'High' : 'Low'}:</span>
                                    <span>${prediction.t} (${prediction.v} ft)</span>
                                </div>
                            `;
                        });
                        html += '</div>';
                        tidesContainer.innerHTML = html;
                    } else {
                        tidesContainer.innerHTML = `<div class="error">No tide data available. <a href="https://tidesandcurrents.noaa.gov/noaatidepredictions.html?id=${CONFIG.NOAA_TIDES_STATION}" target="_blank">Open NOAA</a></div>`;
                    }
                } catch (error) {
                    console.error('Tides fetch error:', error);
                    tidesContainer.innerHTML = `<div class="error">Failed to load tides. <a href="https://tidesandcurrents.noaa.gov/noaatidepredictions.html?id=${CONFIG.NOAA_TIDES_STATION}" target="_blank">Open NOAA</a></div>`;
                }
            }

            // Map functionality
            async initializeMap() {
                const mapContainer = document.getElementById('map');
                if (!mapContainer) return;

                if (this.currentMapMode === 'google') {
                    await this.initializeGoogleMap();
                } else {
                    this.initializeLeafletMap();
                }
            }

            async initializeGoogleMap() {
                try {
                    if (typeof google === 'undefined') {
                        await this.loadGoogleMaps();
                    }

                    this.map = new google.maps.Map(document.getElementById('map'), {
                        center: CONFIG.DEFAULT_CENTER,
                        zoom: CONFIG.DEFAULT_ZOOM,
                        mapId: 'nyc-photo-guide'
                    });

                    this.updateMap();
                } catch (error) {
                    console.error('Failed to load Google Maps, falling back to Leaflet:', error);
                    this.currentMapMode = 'leaflet';
                    document.getElementById('googleTab').classList.remove('active');
                    document.getElementById('leafletTab').classList.add('active');
                    this.initializeLeafletMap();
                }
            }

            async loadGoogleMaps() {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = `https://maps.googleapis.com/maps/api/js?key=${CONFIG.GOOGLE_MAPS_API_KEY}&libraries=places,geometry&callback=initGoogleMaps`;
                    script.async = true;
                    script.onerror = reject;
                    
                    window.initGoogleMaps = resolve;
                    document.head.appendChild(script);
                });
            }

            initializeLeafletMap() {
                if (this.map && this.map.remove) {
                    this.map.remove();
                }

                this.map = L.map('map').setView([CONFIG.DEFAULT_CENTER.lat, CONFIG.DEFAULT_CENTER.lng], CONFIG.DEFAULT_ZOOM);
                
                L.tileLayer('https://upload.wikimedia.org/wikipedia/commons/thumb/f/f2/Tiled_web_map_numbering.png/320px-Tiled_web_map_numbering.png', {
                    attribution: '© OpenStreetMap contributors'
                }).addTo(this.map);

                this.updateMap();
            }

            updateMap() {
                if (!this.map) return;

                // Clear existing markers
                this.clearMarkers();

                // Add markers for filtered locations
                this.filteredLocations.forEach(location => {
                    this.addLocationMarkers(location);
                });

                // Fit bounds to show all markers
                if (this.filteredLocations.length > 0) {
                    this.fitMapBounds();
                }
            }

            clearMarkers() {
                if (this.currentMapMode === 'google') {
                    this.markers.forEach(marker => marker.setMap(null));
                } else {
                    this.markers.forEach(marker => this.map.removeLayer(marker));
                }
                this.markers = [];
            }

            addLocationMarkers(location) {
                const anchor = location.anchors[location.activeAnchor] || location.anchors[0];
                const blockColors = {
                    Morning: '#28a745',
                    Afternoon: '#ffc107',
                    Evening: '#fd7e14',
                    Night: '#6f42c1'
                };

                if (this.currentMapMode === 'google') {
                    // Anchor marker
                    const anchorMarker = new google.maps.Marker({
                        position: { lat: anchor.lat, lng: anchor.lon },
                        map: this.map,
                        title: location.name,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 8,
                            fillColor: blockColors[location.block],
                            fillOpacity: 1,
                            strokeColor: '#ffffff',
                            strokeWeight: 2
                        }
                    });

                    const infoWindow = new google.maps.InfoWindow({
                        content: `<div><strong>${location.name}</strong><br>${location.whyNow}</div>`
                    });

                    anchorMarker.addListener('click', () => {
                        infoWindow.open(this.map, anchorMarker);
                    });

                    this.markers.push(anchorMarker);

                    // Micro-pin markers
                    location.micro.forEach(micro => {
                        const microPos = this.calculateMicroPinPosition(anchor, micro);
                        const microMarker = new google.maps.Marker({
                            position: { lat: microPos.lat, lng: microPos.lng },
                            map: this.map,
                            title: micro.title,
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 4,
                                fillColor: '#17a2b8',
                                fillOpacity: 1,
                                strokeColor: '#ffffff',
                                strokeWeight: 1
                            }
                        });

                        this.markers.push(microMarker);
                    });

                } else {
                    // Leaflet markers
                    const anchorMarker = L.circleMarker([anchor.lat, anchor.lon], {
                        color: '#ffffff',
                        fillColor: blockColors[location.block],
                        fillOpacity: 1,
                        radius: 8,
                        weight: 2
                    }).addTo(this.map);

                    anchorMarker.bindPopup(`<div><strong>${location.name}</strong><br>${location.whyNow}</div>`);
                    this.markers.push(anchorMarker);

                    // Micro-pin markers
                    location.micro.forEach(micro => {
                        const microPos = this.calculateMicroPinPosition(anchor, micro);
                        const microMarker = L.circleMarker([microPos.lat, microPos.lng], {
                            color: '#ffffff',
                            fillColor: '#17a2b8',
                            fillOpacity: 1,
                            radius: 4,
                            weight: 1
                        }).addTo(this.map);

                        microMarker.bindPopup(micro.title);
                        this.markers.push(microMarker);
                    });
                }
            }

            fitMapBounds() {
                if (this.markers.length === 0) return;

                if (this.currentMapMode === 'google') {
                    const bounds = new google.maps.LatLngBounds();
                    this.markers.forEach(marker => {
                        bounds.extend(marker.getPosition());
                    });
                    this.map.fitBounds(bounds);
                } else {
                    const group = new L.featureGroup(this.markers);
                    this.map.fitBounds(group.getBounds().pad(0.1));
                }
            }

            showOnMap(locationId) {
                const location = this.locations.find(loc => loc.id === locationId);
                if (!location) return;

                const anchor = location.anchors[location.activeAnchor] || location.anchors[0];
                
                if (this.currentMapMode === 'google') {
                    this.map.setCenter({ lat: anchor.lat, lng: anchor.lon });
                    this.map.setZoom(16);
                } else {
                    this.map.setView([anchor.lat, anchor.lon], 16);
                }

                this.showToast(`Showing ${location.name} on map`, 'success');
            }

            async getETA(locationId) {
                const location = this.locations.find(loc => loc.id === locationId);
                if (!location) return;

                if (!this.userLocation) {
                    try {
                        this.userLocation = await this.getCurrentLocation();
                    } catch (error) {
                        this.showToast('Location permission required for ETA', 'error');
                        return;
                    }
                }

                const anchor = location.anchors[location.activeAnchor] || location.anchors[0];
                
                if (this.currentMapMode === 'google' && typeof google !== 'undefined') {
                    const service = new google.maps.DistanceMatrixService();
                    service.getDistanceMatrix({
                        origins: [this.userLocation],
                        destinations: [{ lat: anchor.lat, lng: anchor.lon }],
                        travelMode: google.maps.TravelMode.WALKING,
                        unitSystem: google.maps.UnitSystem.METRIC
                    }, (response, status) => {
                        if (status === google.maps.DistanceMatrixStatus.OK) {
                            const element = response.rows[0].elements[0];
                            if (element.status === 'OK') {
                                this.showToast(`ETA to ${location.name}: ${element.duration.text} (${element.distance.text})`, 'success');
                            } else {
                                this.showToast('Could not calculate ETA', 'error');
                            }
                        } else {
                            this.showToast('ETA service unavailable', 'error');
                        }
                    });
                } else {
                    // Fallback: calculate straight-line distance
                    const distance = this.calculateDistance(
                        this.userLocation.lat, this.userLocation.lng,
                        anchor.lat, anchor.lon
                    );
                    const walkingSpeed = 5; // km/h
                    const timeMinutes = Math.round((distance / walkingSpeed) * 60);
                    this.showToast(`Approximate walking time: ${timeMinutes} minutes (${distance.toFixed(1)} km straight line)`, 'success');
                }
            }

            async getRoute(locationId) {
                const location = this.locations.find(loc => loc.id === locationId);
                if (!location) return;

                if (!this.userLocation) {
                    try {
                        this.userLocation = await this.getCurrentLocation();
                    } catch (error) {
                        this.showToast('Location permission required for routing', 'error');
                        return;
                    }
                }

                const anchor = location.anchors[location.activeAnchor] || location.anchors[0];
                
                if (this.currentMapMode === 'google' && typeof google !== 'undefined') {
                    const directionsService = new google.maps.DirectionsService();
                    const directionsRenderer = new google.maps.DirectionsRenderer({
                        map: this.map,
                        suppressMarkers: true
                    });

                    directionsService.route({
                        origin: this.userLocation,
                        destination: { lat: anchor.lat, lng: anchor.lon },
                        travelMode: google.maps.TravelMode.WALKING
                    }, (response, status) => {
                        if (status === 'OK') {
                            directionsRenderer.setDirections(response);
                            this.routes.set(locationId, directionsRenderer);
                            this.showToast(`Route to ${location.name} displayed on map`, 'success');
                        } else {
                            this.showToast('Could not calculate route', 'error');
                        }
                    });
                } else {
                    this.showToast('Routing not available in offline mode', 'error');
                }
            }

            getCurrentLocation() {
                return new Promise((resolve, reject) => {
                    if (!navigator.geolocation) {
                        reject(new Error('Geolocation not supported'));
                        return;
                    }

                    navigator.geolocation.getCurrentPosition(
                        position => {
                            resolve({
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            });
                        },
                        error => {
                            reject(error);
                        },
                        { enableHighAccuracy: true, timeout: 10000, maximumAge: 300000 }
                    );
                });
            }

            calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371; // Earth's radius in km
                const dLat = this.toRad(lat2 - lat1);
                const dLon = this.toRad(lon2 - lon1);
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                         Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) *
                         Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            toRad(value) {
                return value * Math.PI / 180;
            }

            async geocodeLocation(locationId) {
                const location = this.locations.find(loc => loc.id === locationId);
                if (!location) return;

                const addressContainer = document.getElementById(`address-${locationId}`);
                if (!addressContainer) return;

                addressContainer.innerHTML = '<div class="loading">Loading address...</div>';

                const anchor = location.anchors[location.activeAnchor] || location.anchors[0];

                if (this.currentMapMode === 'google' && typeof google !== 'undefined') {
                    const geocoder = new google.maps.Geocoder();
                    geocoder.geocode(
                        { location: { lat: anchor.lat, lng: anchor.lon } },
                        (results, status) => {
                            if (status === 'OK' && results[0]) {
                                addressContainer.innerHTML = `<div class="detail-content">${results[0].formatted_address}</div>`;
                            } else {
                                addressContainer.innerHTML = '<div class="error">Address not found</div>';
                            }
                        }
                    );
                } else {
                    // Fallback: use a free geocoding service
                    try {
                        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${anchor.lat}&lon=${anchor.lon}`);
                        const data = await response.json();
                        if (data.display_name) {
                            addressContainer.innerHTML = `<div class="detail-content">${data.display_name}</div>`;
                        } else {
                            addressContainer.innerHTML = '<div class="error">Address not found</div>';
                        }
                    } catch (error) {
                        console.error('Geocoding error:', error);
                        addressContainer.innerHTML = '<div class="error">Failed to load address</div>';
                    }
                }
            }

            async loadPlacesPhotos(locationId) {
                const location = this.locations.find(loc => loc.id === locationId);
                if (!location) return;

                const imagesContainer = document.getElementById(`images-${locationId}`);
                if (!imagesContainer) return;

                imagesContainer.innerHTML = '<div class="loading">Loading images...</div>';

                if (this.currentMapMode === 'google' && typeof google !== 'undefined') {
                    const service = new google.maps.places.PlacesService(this.map);
                    const anchor = location.anchors[location.activeAnchor] || location.anchors[0];

                    const request = {
                        location: { lat: anchor.lat, lng: anchor.lon },
                        radius: 200,
                        query: location.placeQuery || location.name
                    };

                    service.textSearch(request, (results, status) => {
                        if (status === google.maps.places.PlacesServiceStatus.OK && results.length > 0) {
                            const place = results[0];
                            
                            service.getDetails({ placeId: place.place_id }, (placeDetails, status) => {
                                if (status === google.maps.places.PlacesServiceStatus.OK && placeDetails.photos) {
                                    const photos = placeDetails.photos.slice(0, CONFIG.PLACES_PHOTO_LIMIT);
                                    let html = '<div class="image-gallery">';
                                    
                                    photos.forEach(photo => {
                                        const url = photo.getUrl({ maxWidth: 200, maxHeight: 150 });
                                        html += `<img src="${url}" alt="Reference photo" class="gallery-image" onclick="window.open('${photo.getUrl({ maxWidth: 800, maxHeight: 600 })}', '_blank')">`;
                                    });
                                    
                                    html += '</div>';
                                    imagesContainer.innerHTML = html;
                                } else {
                                    imagesContainer.innerHTML = '<div class="text-muted">No images found.</div>';
                                }
                            });
                        } else {
                            imagesContainer.innerHTML = '<div class="text-muted">No images found.</div>';
                        }
                    });
                } else {
                    imagesContainer.innerHTML = '<div class="text-muted">Images require Google Maps mode.</div>';
                }
            }

            switchMapMode(mode) {
                if (mode === this.currentMapMode) return;

                this.currentMapMode = mode;
                
                // Update tab appearance
                document.getElementById('googleTab').classList.toggle('active', mode === 'google');
                document.getElementById('leafletTab').classList.toggle('active', mode === 'leaflet');
                
                // Clear current map
                const mapContainer = document.getElementById('map');
                mapContainer.innerHTML = '';
                
                // Initialize new map
                this.initializeMap();
            }

            // Export/Import functionality
            exportCSV() {
                const headers = ['Name', 'Day', 'Block', 'Rank', 'Bearing', 'Why Now', 'Gear', 'Settings', 'Lat', 'Lon'];
                let csv = headers.join(',') + '\n';

                this.locations.forEach(location => {
                    const anchor = location.anchors[location.activeAnchor] || location.anchors[0];
                    const row = [
                        `"${location.name}"`,
                        location.day,
                        location.block,
                        location.rank,
                        `"${location.bearing}"`,
                        `"${location.whyNow}"`,
                        `"${location.gear}"`,
                        `"${location.settings}"`,
                        anchor.lat,
                        anchor.lon
                    ];
                    csv += row.join(',') + '\n';
                });

                this.downloadFile(csv, 'nyc-photo-guide.csv', 'text/csv');
            }

            exportKML() {
                let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>NYC Photo Guide</name>
    <description>Photo locations for NYC guide</description>
`;

                this.locations.forEach(location => {
                    const anchor = location.anchors[location.activeAnchor] || location.anchors[0];
                    kml += `
    <Placemark>
      <name>${this.escapeXml(location.name)}</name>
      <description><![CDATA[
        <strong>Day:</strong> ${location.day}<br>
        <strong>Block:</strong> ${location.block}<br>
        <strong>Rank:</strong> ${location.rank}<br>
        <strong>Bearing:</strong> ${location.bearing}<br>
        <strong>Why Now:</strong> ${location.whyNow}<br>
        <strong>Gear:</strong> ${location.gear}<br>
        <strong>Settings:</strong> ${location.settings}
      ]]></description>
      <Point>
        <coordinates>${anchor.lon},${anchor.lat},0</coordinates>
      </Point>
    </Placemark>`;
                });

                kml += `
  </Document>
</kml>`;

                this.downloadFile(kml, 'nyc-photo-guide.kml', 'application/vnd.google-earth.kml+xml');
            }

            exportJSON() {
                const data = {
                    exportDate: new Date().toISOString(),
                    locations: this.locations,
                    filters: this.filters
                };
                
                const json = JSON.stringify(data, null, 2);
                this.downloadFile(json, 'nyc-photo-guide.json', 'application/json');
            }

            importJSON() {
                const fileInput = document.getElementById('importFile');
                fileInput.click();
            }

            handleFileImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (data.locations && Array.isArray(data.locations)) {
                            this.locations = data.locations;
                            if (data.filters) {
                                Object.assign(this.filters, data.filters);
                                this.updateUIFilters();
                            }
                            this.updateFilters();
                            this.showToast('Data imported successfully', 'success');
                        } else {
                            this.showToast('Invalid file format', 'error');
                        }
                    } catch (error) {
                        console.error('Import error:', error);
                        this.showToast('Failed to import data', 'error');
                    }
                };
                reader.readAsText(file);
            }

            updateUIFilters() {
                document.getElementById('dayA').value = this.filters.dayA;
                document.getElementById('dayB').value = this.filters.dayB;
                document.getElementById('showFriSat').checked = this.filters.showFriSat;
                document.getElementById('showMorning').checked = this.filters.blocks.Morning;
                document.getElementById('showAfternoon').checked = this.filters.blocks.Afternoon;
                document.getElementById('showEvening').checked = this.filters.blocks.Evening;
                document.getElementById('showNight').checked = this.filters.blocks.Night;
                document.getElementById('rankMin').value = this.filters.rankMin;
                document.getElementById('rankMax').value = this.filters.rankMax;
                document.getElementById('rankMinValue').textContent = this.filters.rankMin;
                document.getElementById('rankMaxValue').textContent = this.filters.rankMax;
                document.getElementById('searchInput').value = this.filters.search;
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.click();
                URL.revokeObjectURL(url);
            }

            escapeXml(unsafe) {
                return unsafe.replace(/[<>&'"]/g, (c) => {
                    switch (c) {
                        case '<': return '&lt;';
                        case '>': return '&gt;';
                        case '&': return '&amp;';
                        case '\'': return '&apos;';
                        case '"': return '&quot;';
                        default: return c;
                    }
                });
            }

            showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.remove();
                }, 3000);
            }
        }

        // Initialize application
        let app;

        document.addEventListener('DOMContentLoaded', () => {
            app = new AppState();
            app.render();
            app.initializeMap();

            // Event listeners
            document.getElementById('dayA').addEventListener('change', (e) => {
                app.filters.dayA = e.target.value;
                app.updateFilters();
            });

            document.getElementById('dayB').addEventListener('change', (e) => {
                app.filters.dayB = e.target.value;
                app.updateFilters();
            });

            document.getElementById('showFriSat').addEventListener('change', (e) => {
                app.filters.showFriSat = e.target.checked;
                app.updateFilters();
            });

            document.getElementById('showMorning').addEventListener('change', (e) => {
                app.filters.blocks.Morning = e.target.checked;
                app.updateFilters();
            });

            document.getElementById('showAfternoon').addEventListener('change', (e) => {
                app.filters.blocks.Afternoon = e.target.checked;
                app.updateFilters();
            });

            document.getElementById('showEvening').addEventListener('change', (e) => {
                app.filters.blocks.Evening = e.target.checked;
                app.updateFilters();
            });

            document.getElementById('showNight').addEventListener('change', (e) => {
                app.filters.blocks.Night = e.target.checked;
                app.updateFilters();
            });

            document.getElementById('rankMin').addEventListener('input', (e) => {
                app.filters.rankMin = parseInt(e.target.value);
                document.getElementById('rankMinValue').textContent = e.target.value;
                app.updateFilters();
            });

            document.getElementById('rankMax').addEventListener('input', (e) => {
                app.filters.rankMax = parseInt(e.target.value);
                document.getElementById('rankMaxValue').textContent = e.target.value;
                app.updateFilters();
            });

            document.getElementById('searchInput').addEventListener('input', (e) => {
                app.filters.search = e.target.value;
                app.updateFilters();
            });

            document.getElementById('expandAll').addEventListener('click', () => {
                app.expandAllCards();
            });

            document.getElementById('collapseAll').addEventListener('click', () => {
                app.collapseAllCards();
            });

            document.getElementById('exportCSV').addEventListener('click', () => {
                app.exportCSV();
            });

            document.getElementById('exportKML').addEventListener('click', () => {
                app.exportKML();
            });

            document.getElementById('exportJSON').addEventListener('click', () => {
                app.exportJSON();
            });

            document.getElementById('importJSON').addEventListener('click', () => {
                app.importJSON();
            });

            document.getElementById('importFile').addEventListener('change', (e) => {
                app.handleFileImport(e);
            });

            document.getElementById('themeToggle').addEventListener('click', () => {
                app.toggleTheme();
            });

            document.getElementById('googleTab').addEventListener('click', () => {
                app.switchMapMode('google');
            });

            document.getElementById('leafletTab').addEventListener('click', () => {
                app.switchMapMode('leaflet');
            });
        });

        // Global functions for onclick handlers
        window.app = app;
    </script>
</body>
</html>