<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NYC Photo Guide</title>
  <!-- Optional: set your Google Maps key at runtime (fallback if no .env build) -->
  <!-- <meta name="maps:apiKey" content=""> -->

  <!-- Leaflet CSS for offline/fallback map -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="" crossorigin="">

  <style>
    :root {
      --bg: #ffffff;
      --fg: #111111;
      --muted: #555;
      --accent: #0067c5;
      --panel: #f6f7f9;
      --border: #e2e6ec;
      --ok: #0a8754;
      --warn: #b4690e;
      --err: #b00020;

      --morning: #f59e0b;
      --afternoon: #2563eb;
      --evening: #7c3aed;
      --night: #334155;
      --micro: #0d9488;
    }
    [data-theme="dark"] {
      --bg: #0b0e12;
      --fg: #f5f6f8;
      --muted: #aab3c2;
      --accent: #6ab0ff;
      --panel: #141a22;
      --border: #263244;
      --ok: #22c55e;
      --warn: #f59e0b;
      --err: #ef4444;

      --morning: #fbbf24;
      --afternoon: #60a5fa;
      --evening: #a78bfa;
      --night: #94a3b8;
      --micro: #2dd4bf;
    }

    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
      font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    a { color: var(--accent); }
    .wrap {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
    }
    header {
      position: sticky; top: 0; z-index: 10;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }
    .bar {
      display: grid; gap: 8px;
      grid-template-columns: repeat(12, 1fr);
      padding: 10px 12px;
    }
    .bar > * { min-width: 0; }
    .title { grid-column: span 3; font-weight: 700; display:flex; gap:10px; align-items:center; }
    .dates { grid-column: span 3; display:flex; gap:8px; align-items:center; }
    .toggles { grid-column: span 3; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .utils { grid-column: span 3; display:flex; gap:8px; justify-content:flex-end; align-items:center; flex-wrap:wrap; }
    .searchRow { grid-column: 1 / -1; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    .content {
      display: grid; gap: 12px;
      grid-template-columns: 320px 1fr;
      padding: 12px;
      height: calc(100vh - 68px);
    }
    .leftCol {
      overflow: auto;
      padding-right: 6px;
    }
    .panels {
      display: grid; gap: 10px;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
    }
    .panel h3 { margin: 0 0 6px; font-size: 15px; }
    .kv { display:grid; grid-template-columns: 1fr auto; gap:8px; }
    .kv div { color: var(--muted); }
    .kv b { color: var(--fg); }

    .rightCol {
      position: relative;
      min-height: 320px;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      background: var(--panel);
    }
    #gmap, #lmap { position:absolute; inset:0; }
    #lmap { display:none; }

    .list {
      grid-column: 1 / -1;
      height: 100%;
      overflow: auto;
      padding-right: 6px;
    }

    .section {
      margin-top: 12px;
    }
    .section h2 {
      margin: 10px 0;
      font-size: 16px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 6px;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 10px;
      background: var(--bg);
    }
    .cardHeader {
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .badge {
      display:inline-flex; align-items:center; gap:6px;
      padding: 2px 8px; border-radius: 14px; font-size: 12px; border:1px solid var(--border);
      background: var(--panel);
    }
    .badge .dot { width:8px; height:8px; border-radius: 50%; display:inline-block; }
    .dot.morning { background: var(--morning); }
    .dot.afternoon { background: var(--afternoon); }
    .dot.evening { background: var(--evening); }
    .dot.night { background: var(--night); }
    .muted { color: var(--muted); }

    .actions { display:flex; gap:6px; flex-wrap:wrap; }
    .btn {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 13px;
    }
    .btn[disabled] { opacity: 0.5; cursor: default; }
    .btn.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    .btn.warn { border-color: var(--warn); color: var(--warn); }

    details { margin-top: 8px; }
    summary { cursor: pointer; font-weight: 600; }

    .pills { display:flex; gap:6px; flex-wrap:wrap; margin:6px 0; }
    .pill {
      border:1px solid var(--border); background: var(--panel);
      border-radius: 999px; padding:4px 10px; font-size: 12px; cursor: pointer;
    }
    .pill.active { outline: 2px solid var(--accent); }

    .grid {
      display:grid; gap:8px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
    .grid.kv { grid-template-columns: 120px 1fr; }
    .grid.photos { grid-template-columns: repeat(3, minmax(0, 1fr)); }
    .photos img { width:100%; height: 100px; object-fit: cover; border-radius: 6px; }

    .toast {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 12px; padding: 10px 12px; border-radius: 8px;
      background: var(--panel); border:1px solid var(--border);
      box-shadow: 0 6px 20px rgba(0,0,0,.25);
      display:none; z-index: 50;
      max-width: 90vw;
    }
    .toast.show { display: block; }

    .rangeRow { display:flex; align-items:center; gap:6px; }
    .rangeRow input[type=range] { width: 130px; }

    .mapTabs { display:flex; gap:10px; }
    .mapTabs label { display:flex; gap:6px; align-items:center; cursor: pointer; }

    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="bar" role="region" aria-label="App controls">
        <div class="title">
          <span style="font-size:18px;">ðŸ“¸ NYC Photo Guide</span>
          <span class="mapTabs" role="tablist" aria-label="Map engine">
            <label><input type="radio" name="mapMode" value="google" checked aria-label="Google Maps (online)" /> Google</label>
            <label><input type="radio" name="mapMode" value="leaflet" aria-label="Leaflet (offline)"/> Leaflet</label>
          </span>
        </div>

        <div class="dates">
          <label>Day A <input id="dayA" type="date" aria-label="Pick Day A date"/></label>
          <label>Day B <input id="dayB" type="date" aria-label="Pick Day B date"/></label>
        </div>

        <div class="toggles">
          <label><input id="showA" type="checkbox" checked aria-label="Show Day A"/> Show A</label>
          <label><input id="showB" type="checkbox" checked aria-label="Show Day B"/> Show B</label>

          <label><input class="blk" value="Morning" type="checkbox" checked/> Morning</label>
          <label><input class="blk" value="Afternoon" type="checkbox" checked/> Afternoon</label>
          <label><input class="blk" value="Evening" type="checkbox" checked/> Evening</label>
          <label><input class="blk" value="Night" type="checkbox" checked/> Night</label>

          <div class="rangeRow" title="Rank filter">
            <span id="rankLabel" class="muted">#1â€“#5</span>
            <input id="rankMin" type="range" min="1" max="5" value="1" aria-label="Minimum rank"/>
            <input id="rankMax" type="range" min="1" max="5" value="5" aria-label="Maximum rank"/>
          </div>
        </div>

        <div class="utils">
          <button id="expandAll" class="btn" aria-label="Expand all cards">Expand all</button>
          <button id="collapseAll" class="btn" aria-label="Collapse all cards">Collapse</button>
          <button id="exportCSV" class="btn" aria-label="Export CSV">Export CSV</button>
          <button id="exportKML" class="btn" aria-label="Export KML">Export KML</button>
          <button id="exportJSON" class="btn" aria-label="Export JSON">Export JSON</button>
          <label class="btn" title="Import JSON">
            Import JSON
            <input id="importJSON" type="file" accept="application/json" class="sr-only"/>
          </label>
          <button id="printBtn" class="btn" aria-label="Print">Print</button>
          <button id="themeBtn" class="btn" aria-label="Toggle theme">Theme</button>
        </div>

        <div class="searchRow">
          <input id="q" type="search" placeholder="Search (name, gear, why, pins, shotsâ€¦)" style="flex:1; padding:6px 10px; border-radius: 6px; border:1px solid var(--border); background:var(--bg); color:var(--fg);" aria-label="Search"/>
        </div>
      </div>
    </header>

    <div class="content">
      <div class="leftCol">
        <div class="panels">
          <div class="panel" id="panelA" aria-live="polite">
            <h3>Day A â€” Light & Moon</h3>
            <div class="kv">
              <div>Date</div><b id="labelA">â€”</b>
              <div>Dawn</div><b id="aDawn">â€”</b>
              <div>Sunrise</div><b id="aSunrise">â€”</b>
              <div>Sunset</div><b id="aSunset">â€”</b>
              <div>Dusk</div><b id="aDusk">â€”</b>
              <div>Moonrise</div><b id="aMoonrise">â€”</b>
              <div>Moonset</div><b id="aMoonset">â€”</b>
              <div>Illumination</div><b id="aIllum">â€”</b>
              <div>Tides (Battery)</div><b id="aTides">â€”</b>
            </div>
          </div>
          <div class="panel" id="panelB" aria-live="polite">
            <h3>Day B â€” Light & Moon</h3>
            <div class="kv">
              <div>Date</div><b id="labelB">â€”</b>
              <div>Dawn</div><b id="bDawn">â€”</b>
              <div>Sunrise</div><b id="bSunrise">â€”</b>
              <div>Sunset</div><b id="bSunset">â€”</b>
              <div>Dusk</div><b id="bDusk">â€”</b>
              <div>Moonrise</div><b id="bMoonrise">â€”</b>
              <div>Moonset</div><b id="bMoonset">â€”</b>
              <div>Illumination</div><b id="bIllum">â€”</b>
              <div>Tides (Battery)</div><b id="bTides">â€”</b>
            </div>
          </div>
        </div>
      </div>

      <div class="rightCol">
        <div id="gmap" role="region" aria-label="Google Map"></div>
        <div id="lmap" role="region" aria-label="Leaflet Map"></div>
      </div>

      <div class="list" id="list" aria-live="polite" aria-busy="false">
        <!-- Cards injected -->
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  
<script type="module">
// Build blob-URL modules, inject an import map into <head>, then import('app').
// Note: document.currentScript is null inside module scripts, so we don't use it.
const MODULES = {"app": "// app.js \u2014 main SPA logic (ES modules, no globals)\nimport { LOCATIONS } from 'data/locations';\nimport { getGoogleMapsApiKey, STORAGE, saveLocal, loadLocal, fmtTime, NYC } from 'config';\nimport { computeLightAndMoon } from 'lib/sunmoon';\nimport { GoogleMapEngine } from 'map-google';\nimport { LeafletMapEngine } from 'map-leaflet';\nimport { loadGoogleMaps } from './lib/googleLoader.js';\n\n\nconst OVERRIDE_KEY = 'NYCPhotoGuide:overrideLocations';\nlet RUNTIME_LOCATIONS = (() => {\n  try { const o = localStorage.getItem(OVERRIDE_KEY); return o ? JSON.parse(o) : LOCATIONS; } catch(e){ return LOCATIONS; }\n})();\n\nfunction getLocations() {\n  return RUNTIME_LOCATIONS;\n}\nconst state = {\n  dayA: null,\n  dayB: null,\n  showA: true,\n  showB: true,\n  blocks: { Morning: true, Afternoon: true, Evening: true, Night: true },\n  rankMin: 1,\n  rankMax: 5,\n  q: '',\n  mapMode: 'google',\n  dayMap: {}, // 'YYYY-MM-DD' => 'A'/'B'\n  anchors: loadLocal(STORAGE.anchors, {}),\n  activeAnchor: loadLocal(STORAGE.activeAnchor, {}),\n};\n\nconst $ = (q, el=document) => el.querySelector(q);\nconst $$ = (q, el=document) => Array.from(el.querySelectorAll(q));\n\nfunction toast(msg, cls='') {\n  const t = $('#toast');\n  t.textContent = msg; t.className = 'toast show ' + cls;\n  const onKey = (e)=>{ if(e.key==='Escape') hide(); }\n  function hide(){ t.className = 'toast'; window.removeEventListener('keydown', onKey); }\n  setTimeout(hide, 4000);\n  window.addEventListener('keydown', onKey);\n}\n\nfunction groupByDayBlock(items) {\n  const g = {};\n  for (const it of items) {\n    const day = it.day;\n    g[day] = g[day] || { Morning: [], Afternoon: [], Evening: [], Night: [] };\n    g[day][it.block].push(it);\n  }\n  for (const d of Object.keys(g)) {\n    for (const b of Object.keys(g[d])) g[d][b] = g[d][b].sort((a,b)=>a.rank-b.rank);\n  }\n  return g;\n}\n\nfunction applyAnchorOverrides(loc) {\n  // Persisted anchor edits\n  const o = state.anchors?.[loc.id];\n  if (!o) return loc;\n  const copy = JSON.parse(JSON.stringify(loc));\n  for (const k of Object.keys(o)) {\n    if (copy.anchors[k]) {\n      copy.anchors[k].lat = o[k].lat;\n      copy.anchors[k].lon = o[k].lon;\n    }\n  }\n  // Active anchor selection\n  const aa = state.activeAnchor?.[loc.id];\n  if (typeof aa === 'number') copy.activeAnchor = aa;\n  return copy;\n}\n\nfunction filtered() {\n  const q = state.q.trim().toLowerCase();\n  const dateFilter = (loc) => {\n    const label = state.dayMap[loc.day];\n    if (label === 'A' && !state.showA) return false;\n    if (label === 'B' && !state.showB) return false;\n    return true;\n  };\n  const blockFilter = (loc) => !!state.blocks[loc.block];\n  const rankFilter = (loc) => loc.rank >= state.rankMin && loc.rank <= state.rankMax;\n  const searchFilter = (loc) => {\n    if (!q) return true;\n    const hay = [loc.name, loc.whyNow, loc.gear, loc.settings]\n      .concat((loc.pins||[]).map(p=>\\`${p.title} ${p.detail}\\`))\n      .concat((loc.shots||[]).map(s=>\\`${s.title} ${s.detail}\\`))\n      .join(' ').toLowerCase();\n    return hay.includes(q);\n  };\n  return getLocations().map(applyAnchorOverrides).filter(l => dateFilter(l) && blockFilter(l) && rankFilter(l) && searchFilter(l));\n}\n\nfunction badgeDot(block) {\n  const cls = block.toLowerCase();\n  return \\`<span class=\"dot ${cls}\" aria-hidden=\"true\"></span>\\`;\n}\n\nfunction dayLabel(dateStr) {\n  const d = new Date(dateStr + 'T00:00:00');\n  const lab = d.toLocaleDateString([], { weekday:'short', month:'short', day:'numeric' });\n  const ab = state.dayMap[dateStr] || '?';\n  return \\`${ab} \u2022 ${lab}\\`;\n}\n\nfunction microLatLon(anchor, micro) {\n  const bearing = (micro.bearing || 0) * Math.PI / 180;\n  const lat = anchor.lat;\n  const dlat = (micro.r * Math.cos(bearing)) / 111111;\n  const dlon = (micro.r * Math.sin(bearing)) / (111111 * Math.cos(lat * Math.PI/180));\n  return { lat: lat + dlat, lon: anchor.lon + dlon };\n}\n\nfunction cardHTML(loc) {\n  const a = loc.anchors[loc.activeAnchor||0] || loc.anchors[0];\n  const dl = dayLabel(loc.day);\n  const summary = \\`${dl} \u2022 ${loc.block} \u2022 ${loc.bearing}\\`;\n  const anchorPills = (loc.anchors||[]).map((anc, i)=>{\n    const active = i === (loc.activeAnchor||0);\n    return \\`<button class=\"pill anchor-pill ${active?'active':''}\" data-id=\"${loc.id}\" data-index=\"${i}\" aria-label=\"Use anchor ${anc.label}\">${anc.label}</button>\\`;\n  }).join('');\n\n  const microPills = (loc.micro||[]).map((m,i)=>{\n    const p = microLatLon(a, m);\n    const walk = \\`https://www.google.com/maps/dir/?api=1&destination=${p.lat},${p.lon}&travelmode=walking\\`;\n    return \\`<a class=\"pill\" href=\"${walk}\" target=\"_blank\" rel=\"noopener\" aria-label=\"Walk to ${m.title}\">${m.title} \u2192</a>\\`;\n  }).join('');\n\n  const open = \\`https://www.google.com/maps/search/?api=1&query=${a.lat},${a.lon}\\`;\n  const walk = \\`https://www.google.com/maps/dir/?api=1&destination=${a.lat},${a.lon}&travelmode=walking\\`;\n\n  return \\`\n    <div class=\"card\" id=\"card-${loc.id}\">\n      <div class=\"cardHeader\">\n        <div>\n          <div style=\"display:flex; gap:8px; align-items:center; flex-wrap:wrap;\">\n            <strong>${loc.name}</strong>\n            <span class=\"badge\"><span class=\"muted\">Rank</span> <b>#${loc.rank}</b></span>\n            <span class=\"badge\"><span class=\"muted\">Block</span> ${badgeDot(loc.block)} <b>${loc.block}</b></span>\n          </div>\n          <div class=\"muted\">${summary}</div>\n        </div>\n        <div class=\"actions\">\n          <button class=\"btn showMap\" data-id=\"${loc.id}\">Show on map</button>\n          <button class=\"btn eta\" data-id=\"${loc.id}\">ETA</button>\n          <button class=\"btn route\" data-id=\"${loc.id}\">Route</button>\n          <a class=\"btn\" href=\"${open}\" target=\"_blank\" rel=\"noopener\">Open (anchor)</a>\n          <a class=\"btn\" href=\"${walk}\" target=\"_blank\" rel=\"noopener\">Walk to anchor</a>\n        </div>\n      </div>\n\n      <div class=\"pills\" role=\"group\" aria-label=\"Anchor options\">${anchorPills}</div>\n      <div class=\"pills\" role=\"group\" aria-label=\"Micro pins\">${microPills}</div>\n\n      <details>\n        <summary>Details</summary>\n        <div class=\"grid kv\" style=\"margin-top:6px;\">\n          <div>Why now</div><div>${loc.whyNow}</div>\n          <div>Timing</div><div>${loc.settings}</div>\n          <div>Face & light</div><div>${loc.bearing}</div>\n          <div>Gear</div><div>${loc.gear}</div>\n          <div>Tides</div><div class=\"tides\" data-id=\"${loc.id}\" data-day=\"${loc.day}\">Loading\u2026</div>\n          <div>Moon</div><div class=\"moon\" data-day=\"${loc.day}\">\u2014</div>\n          <div>Address</div><div class=\"addr\" data-lat=\"${a.lat}\" data-lon=\"${a.lon}\">\u2014</div>\n        </div>\n\n        <div style=\"margin-top:6px;\">\n          <div><b>Pins</b></div>\n          <ul>${(loc.pins||[]).map(p=>\\`<li><b>${p.title}:</b> ${p.detail}</li>\\`).join('')}</ul>\n        </div>\n        <div>\n          <div><b>Shots</b></div>\n          <ul>${(loc.shots||[]).map(s=>\\`<li><b>${s.title}:</b> ${s.detail}</li>\\`).join('')}</ul>\n        </div>\n\n        <div style=\"margin-top:6px;\">\n          <button class=\"btn photosBtn\" data-id=\"${loc.id}\">Reference Images</button>\n          <div class=\"grid photos\" id=\"photos-${loc.id}\" style=\"margin-top:6px;\"></div>\n        </div>\n\n        <div style=\"margin-top:6px;\">\n          <button class=\"btn warn editAnchorBtn\" data-id=\"${loc.id}\">Edit anchor lat/lon</button>\n          <div id=\"edit-${loc.id}\" style=\"display:none; margin-top:4px;\">\n            <label>Lat <input type=\"number\" step=\"0.0000001\" class=\"anchor-lat\" value=\"${a.lat}\"/></label>\n            <label>Lon <input type=\"number\" step=\"0.0000001\" class=\"anchor-lon\" value=\"${a.lon}\"/></label>\n            <button class=\"btn saveAnchorBtn\" data-id=\"${loc.id}\">Save</button>\n          </div>\n        </div>\n      </details>\n    </div>\n  \\`;\n}\n\nfunction renderList() {\n  const list = $('#list');\n  list.setAttribute('aria-busy', 'true');\n  const items = filtered();\n  const g = groupByDayBlock(items);\n  const days = Object.keys(g).sort(); // chronological\n  let html = '';\n  for (const day of days) {\n    const label = dayLabel(day);\n    for (const block of ['Morning','Afternoon','Evening','Night']) {\n      const arr = g[day][block] || [];\n      if (!arr.length) continue;\n      html += \\`<div class=\"section\" data-day=\"${day}\" data-block=\"${block}\"><h2>${label} \u2014 ${block}</h2>\\`;\n      html += arr.map(cardHTML).join('');\n      html += \\`</div>\\`;\n    }\n  }\n  list.innerHTML = html || '<div class=\"muted\" style=\"padding:8px;\">No results match current filters.</div>';\n  list.setAttribute('aria-busy', 'false');\n\n  // Wire actions\n  $$('.showMap').forEach(b=>b.addEventListener('click', () => {\n    const id = b.dataset.id;\n    const loc = filtered().find(x=>x.id===id);\n    engine.fitToLocation(loc);\n  }));\n  $$('.anchor-pill').forEach(p=>p.addEventListener('click', ()=>{\n    const id = p.dataset.id; const idx = Number(p.dataset.index);\n    state.activeAnchor[id] = idx;\n    saveLocal(STORAGE.activeAnchor, state.activeAnchor);\n    renderAll();\n  }));\n  $$('.eta').forEach(b=>b.addEventListener('click', ()=> onETA(b.dataset.id)));\n  $$('.route').forEach(b=>b.addEventListener('click', ()=> onRoute(b.dataset.id)));\n\n  $$('.photosBtn').forEach(b=>b.addEventListener('click', ()=> loadPhotos(b.dataset.id)));\n  $$('.editAnchorBtn').forEach(b=>{\n    b.addEventListener('click', ()=>{\n      const id = b.dataset.id;\n      const box = $('#edit-'+id);\n      box.style.display = box.style.display === 'none' ? 'block' : 'none';\n    });\n  });\n  $$('.saveAnchorBtn').forEach(b=>b.addEventListener('click', ()=>{\n    const id = b.dataset.id;\n    const wrap = $('#edit-'+id);\n    const lat = Number($('.anchor-lat', wrap).value);\n    const lon = Number($('.anchor-lon', wrap).value);\n    if (!isFinite(lat) || !isFinite(lon)) return toast('Invalid lat/lon');\n    const exists = state.anchors[id] || {};\n    const loc = getLocations().find(x=>x.id===id);\n    const ai = (state.activeAnchor[id] != null) ? state.activeAnchor[id] : (loc.activeAnchor||0);\n    exists[ai] = { lat, lon };\n    state.anchors[id] = exists;\n    saveLocal(STORAGE.anchors, state.anchors);\n    toast('Anchor updated and saved.');\n    renderAll();\n  }));\n\n  // Fill tides & moon inline\n  $$('.tides').forEach(el => {\n    const day = el.dataset.day;\n    fetchTides(day).then(str => { el.textContent = str; })\n      .catch(()=> el.innerHTML = \\`<a href=\"https://tidesandcurrents.noaa.gov/noaatidepredictions.html?id=8518750\" target=\"_blank\" rel=\"noopener\">Open NOAA high/low</a>\\`);\n  });\n  $$('.moon').forEach(el => {\n    const day = el.dataset.day;\n    const d = new Date(day + 'T12:00:00');\n    const lm = lightByDay[day];\n    if (lm) {\n      const ill = Math.round(lm.illum * 100) + '%';\n      const mr = fmtTime(lm.moonrise);\n      const ms = fmtTime(lm.moonset);\n      el.textContent = \\`Rise ${mr} \u2022 Set ${ms} \u2022 ${ill}\\`;\n    } else {\n      el.textContent = '\u2014';\n    }\n  });\n\n  // Resolve address via Geocoder if available\n  geocodeAll();\n}\n\nlet engine = null; // current map engine instance\nlet engineMode = 'google';\nlet googleKey = '';\n\nasync function ensureEngine(mode) {\n  if (engine && engineMode === mode) return engine;\n  // Tear down previous\n  if (engine && engine.clear) engine.clear();\n  // Hide/show containers\n  $('#gmap').style.display = mode === 'google' ? 'block' : 'none';\n  $('#lmap').style.display = mode === 'leaflet' ? 'block' : 'none';\n  if (mode === 'google') {\n    if (!googleKey) googleKey = await getGoogleMapsApiKey();\n    try {\n      engine = new GoogleMapEngine($('#gmap'), googleKey);\n      await engine.init();\n      engineMode = 'google';\n    } catch(e) {\n      console.warn('Google failed, swapping to Leaflet', e);\n      toast('Google Maps failed \u2014 using Leaflet fallback.');\n      engine = new LeafletMapEngine($('#lmap'));\n      await engine.init();\n      engineMode = 'leaflet';\n    }\n  } else {\n    engine = new LeafletMapEngine($('#lmap'));\n    await engine.init();\n    engineMode = 'leaflet';\n  }\n  return engine;\n}\n\nfunction blockColor(block) {\n  return getComputedStyle(document.documentElement).getPropertyValue('--' + block.toLowerCase()).trim();\n}\n\nasync function onETA(id) {\n  const loc = filtered().find(x=>x.id===id);\n  const a = loc.anchors[loc.activeAnchor||0] || loc.anchors[0];\n  // Geolocation guard\n  if (!navigator.geolocation) return toast('Geolocation not available in this browser.');\n  navigator.geolocation.getCurrentPosition(async pos => {\n    const from = { lat: pos.coords.latitude, lon: pos.coords.longitude };\n    try {\n      if (!window.google || !window.google.maps) {\n        // Load Google for Distance Matrix even in Leaflet mode\n        if (!googleKey) googleKey = await getGoogleMapsApiKey();\n        await loadGoogleMaps(googleKey, ['places']);\n      }\n      const svc = new google.maps.DistanceMatrixService();\n      svc.getDistanceMatrix({\n        origins: [new google.maps.LatLng(from.lat, from.lon)],\n        destinations: [new google.maps.LatLng(a.lat, a.lon)],\n        travelMode: google.maps.TravelMode.WALKING\n      }, (res, status) => {\n        if (status === 'OK' && res && res.rows[0].elements[0].status === 'OK') {\n          const el = res.rows[0].elements[0];\n          toast(\\`ETA ${el.duration.text} \u2022 ${el.distance.text}\\`);\n        } else {\n          toast('Distance Matrix failed.');\n        }\n      });\n    } catch(e) {\n      console.warn(e);\n      toast('Google API unavailable for ETA.');\n    }\n  }, err => {\n    toast('Geolocation denied.');\n  }, { enableHighAccuracy: true, timeout: 8000 });\n}\n\nasync function onRoute(id) {\n  const loc = filtered().find(x=>x.id===id);\n  const a = loc.anchors[loc.activeAnchor||0] || loc.anchors[0];\n  if (engineMode !== 'google') return toast('Route drawing available in Google mode only.');\n  if (!navigator.geolocation) return toast('Geolocation not available.');\n  navigator.geolocation.getCurrentPosition(async pos => {\n    const from = { lat: pos.coords.latitude, lon: pos.coords.longitude };\n    try {\n      await engine.drawRoute(from, { lat: a.lat, lon: a.lon });\n      toast('Route drawn on map.');\n    } catch(e) {\n      toast('Directions failed.');\n    }\n  }, err => toast('Geolocation denied.'), { enableHighAccuracy: true, timeout: 8000 });\n}\n\n// NOAA tides\nconst noaaCache = {};\nasync function fetchTides(dayStr) {\n  if (noaaCache[dayStr]) return noaaCache[dayStr];\n  const ymd = dayStr.replace(/-/g, '');\n  const url = \\`https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?product=predictions&begin_date=${ymd}&end_date=${ymd}&datum=MLLW&station=8518750&time_zone=lst_ldt&interval=hilo&units=english&format=json\\`;\n  const res = await fetch(url, { cache: 'no-store' });\n  if (!res.ok) throw new Error('NOAA error');\n  const j = await res.json();\n  const preds = j?.predictions || [];\n  const txt = preds.map(p=>\\`${p.type.toUpperCase()} ${new Date(p.t).toLocaleTimeString([], { hour:'numeric', minute:'2-digit' })} ${p.v} ft\\`).join(' \u2022 ');\n  const out = txt || '\u2014';\n  noaaCache[dayStr] = out;\n  return out;\n}\n\n// Places Photos (lazy)\nasync function loadPhotos(id) {\n  const loc = filtered().find(x=>x.id===id);\n  const a = loc.anchors[loc.activeAnchor||0] || loc.anchors[0];\n  const grid = $('#photos-' + id);\n  grid.innerHTML = 'Loading\u2026';\n  try {\n    if (!googleKey) googleKey = await getGoogleMapsApiKey();\n    await loadGoogleMaps(googleKey, ['places']);\n    const svc = new google.maps.places.PlacesService(document.createElement('div'));\n    const query = loc.placeQuery || loc.name;\n    const req = {\n      query,\n      fields: ['name', 'photos', 'geometry'],\n      locationBias: { radius: 800, center: new google.maps.LatLng(a.lat, a.lon) }\n    };\n    svc.findPlaceFromQuery(req, (results, status) => {\n      if (status !== google.maps.places.PlacesServiceStatus.OK || !results || !results.length) {\n        grid.innerHTML = '<div class=\"muted\">No images found.</div>';\n        return;\n      }\n      const photos = [];\n      for (const r of results) {\n        for (const p of (r.photos || [])) {\n          const url = p.getUrl({ maxWidth: 480, maxHeight: 480 });\n          if (url) photos.push(url);\n          if (photos.length >= 12) break;\n        }\n        if (photos.length >= 12) break;\n      }\n      if (!photos.length) {\n        grid.innerHTML = '<div class=\"muted\">No images found.</div>';\n      } else {\n        grid.innerHTML = photos.map(u=>\\`<img loading=\"lazy\" src=\"${u}\" alt=\"Reference image\"/>\\`).join('');\n      }\n    });\n  } catch(e) {\n    console.warn(e);\n    grid.innerHTML = '<div class=\"muted\">Could not load images (network/API issue).</div>';\n  }\n}\n\n// Geocode address (Google if available); otherwise leave '\u2014'\nasync function geocodeAll() {\n  if (!window.google || !google.maps) return;\n  const geocoder = new google.maps.Geocoder();\n  $$('.addr').forEach(el => {\n    const lat = Number(el.dataset.lat), lon = Number(el.dataset.lon);\n    geocoder.geocode({ location: { lat, lng: lon } }, (res, status) => {\n      if (status === 'OK' && res && res[0]) {\n        el.textContent = res[0].formatted_address;\n      }\n    });\n  });\n}\n\n// Light/Moon panels per day\nconst lightByDay = {};\nfunction renderLightPanels() {\n  const a = new Date(state.dayA + 'T12:00:00');\n  const b = new Date(state.dayB + 'T12:00:00');\n  const ca = computeLightAndMoon(a, NYC.lat, NYC.lon);\n  const cb = computeLightAndMoon(b, NYC.lat, NYC.lon);\n  lightByDay[state.dayA] = ca;\n  lightByDay[state.dayB] = cb;\n\n  $('#labelA').textContent = a.toLocaleDateString();\n  $('#aDawn').textContent = fmtTime(ca.dawn);\n  $('#aSunrise').textContent = fmtTime(ca.sunrise);\n  $('#aSunset').textContent = fmtTime(ca.sunset);\n  $('#aDusk').textContent = fmtTime(ca.dusk);\n  $('#aMoonrise').textContent = fmtTime(ca.moonrise);\n  $('#aMoonset').textContent = fmtTime(ca.moonset);\n  $('#aIllum').textContent = Math.round(ca.illum*100) + '%';\n\n  $('#labelB').textContent = b.toLocaleDateString();\n  $('#bDawn').textContent = fmtTime(cb.dawn);\n  $('#bSunrise').textContent = fmtTime(cb.sunrise);\n  $('#bSunset').textContent = fmtTime(cb.sunset);\n  $('#bDusk').textContent = fmtTime(cb.dusk);\n  $('#bMoonrise').textContent = fmtTime(cb.moonrise);\n  $('#bMoonset').textContent = fmtTime(cb.moonset);\n  $('#bIllum').textContent = Math.round(cb.illum*100) + '%';\n\n  // Tides panels\n  $('#aTides').textContent = 'Loading\u2026';\n  $('#bTides').textContent = 'Loading\u2026';\n  fetchTides(state.dayA).then(s=> $('#aTides').textContent = s).catch(()=> $('#aTides').innerHTML = \\`<a href=\"https://tidesandcurrents.noaa.gov/noaatidepredictions.html?id=8518750\" target=\"_blank\" rel=\"noopener\">Open NOAA high/low</a>\\`);\n  fetchTides(state.dayB).then(s=> $('#bTides').textContent = s).catch(()=> $('#bTides').innerHTML = \\`<a href=\"https://tidesandcurrents.noaa.gov/noaatidepredictions.html?id=8518750\" target=\"_blank\" rel=\"noopener\">Open NOAA high/low</a>\\`);\n}\n\nfunction defaultDayMap() {\n  // Use the two distinct days present in the dataset\n  const days = Array.from(new Set(getLocations().map(l=>l.day))).sort();\n  const map = {};\n  if (days[0]) map[days[0]] = 'A';\n  if (days[1]) map[days[1]] = 'B';\n  return map;\n}\n\nasync function renderMap() {\n  const eng = await ensureEngine(state.mapMode);\n  eng.render(filtered());\n}\n\nfunction renderAll() {\n  renderLightPanels();\n  renderList();\n  renderMap();\n}\n\nfunction setupControls() {\n  // day inputs; default from dataset\n  const days = Array.from(new Set(getLocations().map(l=>l.day))).sort();\n  state.dayA = days[0] || new Date().toISOString().slice(0,10);\n  state.dayB = days[1] || new Date(Date.now()+86400000).toISOString().slice(0,10);\n  state.dayMap = defaultDayMap();\n\n  $('#dayA').value = state.dayA;\n  $('#dayB').value = state.dayB;\n  $('#dayA').addEventListener('change', e => {\n    state.dayA = e.target.value;\n    state.dayMap = defaultDayMap(); // keep labels tied to specific dates\n    renderAll();\n  });\n  $('#dayB').addEventListener('change', e => {\n    state.dayB = e.target.value;\n    state.dayMap = defaultDayMap();\n    renderAll();\n  });\n\n  $('#showA').checked = state.showA;\n  $('#showB').checked = state.showB;\n  $('#showA').addEventListener('change', e => { state.showA = e.target.checked; renderAll(); });\n  $('#showB').addEventListener('change', e => { state.showB = e.target.checked; renderAll(); });\n\n  $$('.blk').forEach(chk => {\n    chk.checked = !!state.blocks[chk.value];\n    chk.addEventListener('change', e=> { state.blocks[chk.value] = chk.checked; renderAll(); });\n  });\n\n  const updateRankLabel = () => {\n    if (state.rankMin > state.rankMax) { const t = state.rankMin; state.rankMin = state.rankMax; state.rankMax = t; }\n    $('#rankLabel').textContent = \\`#${state.rankMin}\u2013#${state.rankMax}\\`;\n  };\n  $('#rankMin').value = state.rankMin;\n  $('#rankMax').value = state.rankMax;\n  $('#rankMin').addEventListener('input', e => { state.rankMin = Number(e.target.value); updateRankLabel(); renderAll(); });\n  $('#rankMax').addEventListener('input', e => { state.rankMax = Number(e.target.value); updateRankLabel(); renderAll(); });\n  updateRankLabel();\n\n  $('#q').addEventListener('input', e => { state.q = e.target.value; renderAll(); });\n\n  // Map mode\n  $$('input[name=\"mapMode\"]').forEach(r => {\n    if (r.value === state.mapMode) r.checked = true;\n    r.addEventListener('change', async (e) => {\n      if (e.target.checked) {\n        state.mapMode = e.target.value;\n        await ensureEngine(state.mapMode);\n        renderMap();\n      }\n    });\n  });\n\n  // Utilities\n  $('#expandAll').addEventListener('click', ()=> $$('details').forEach(d=> d.open = true));\n  $('#collapseAll').addEventListener('click', ()=> $$('details').forEach(d=> d.open = false));\n  $('#exportCSV').addEventListener('click', exportCSV);\n  $('#exportKML').addEventListener('click', exportKML);\n  $('#exportJSON').addEventListener('click', exportJSON);\n  $('#importJSON').addEventListener('change', importJSON);\n  $('#printBtn').addEventListener('click', ()=> window.print());\n\n  // Theme\n  const savedTheme = loadLocal(STORAGE.theme, null);\n  if (savedTheme) document.documentElement.setAttribute('data-theme', savedTheme);\n  $('#themeBtn').addEventListener('click', ()=> {\n    const cur = document.documentElement.getAttribute('data-theme') || 'light';\n    const next = cur === 'light' ? 'dark' : 'light';\n    document.documentElement.setAttribute('data-theme', next);\n    saveLocal(STORAGE.theme, next);\n  });\n\n  // Accessibility helpers\n  window.addEventListener('keydown', e=> {\n    if (e.key === 'Enter' && document.activeElement?.classList.contains('pill')) {\n      document.activeElement.click();\n    }\n  });\n}\n\nfunction download(filename, text, type='text/plain') {\n  const blob = new Blob([text], { type });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url; a.download = filename; a.click();\n  setTimeout(()=> URL.revokeObjectURL(url), 1500);\n}\n\nfunction exportCSV() {\n  // Flatten to anchors (active) + micro pins\n  const items = filtered();\n  const rows = [['id','name','day','block','rank','anchorLabel','lat','lon','microTitle','microLat','microLon']];\n  for (const loc of items) {\n    const a = loc.anchors[loc.activeAnchor||0] || loc.anchors[0];\n    if (!(loc.micro && loc.micro.length)) {\n      rows.push([loc.id, loc.name, loc.day, loc.block, loc.rank, a.label, a.lat, a.lon, '', '', '']);\n    } else {\n      for (const m of loc.micro) {\n        const p = microLatLon(a, m);\n        rows.push([loc.id, loc.name, loc.day, loc.block, loc.rank, a.label, a.lat, a.lon, m.title, p.lat, p.lon]);\n      }\n    }\n  }\n  const csv = rows.map(r => r.map(v => \\`\"${String(v).replace(/\"/g,'\"\"')}\"\\`).join(',')).join('\\n');\n  download('nyc-photo-guide.csv', csv, 'text/csv');\n}\n\nfunction exportKML() {\n  const items = filtered();\n  const esc = (s)=> String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');\n  let kml = \\`<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<kml xmlns=\"http://www.opengis.net/kml/2.2\">\n  <Document>\n    <name>NYC Photo Guide</name>\n\\`;\n  for (const loc of items) {\n    const a = loc.anchors[loc.activeAnchor||0] || loc.anchors[0];\n    kml += \\`    <Placemark><name>${esc(loc.name)} (Anchor: ${esc(a.label)})</name><Point><coordinates>${a.lon},${a.lat},0</coordinates></Point></Placemark>\\n\\`;\n    for (const m of loc.micro || []) {\n      const p = microLatLon(a, m);\n      kml += \\`    <Placemark><name>${esc(loc.name)} \u2014 ${esc(m.title)}</name><Point><coordinates>${p.lon},${p.lat},0</coordinates></Point></Placemark>\\n\\`;\n    }\n  }\n  kml += \\`  </Document>\\n</kml>\\`;\n  download('nyc-photo-guide.kml', kml, 'application/vnd.google-earth.kml+xml');\n}\n\nfunction exportJSON() {\n  const out = {\n    LOCATIONS: getLocations(), // current dataset (original or imported override) (edits are persisted separately to keep diff clear)\n    state: {\n      dayMap: state.dayMap\n    }\n  };\n  download('nyc-photo-guide.json', JSON.stringify(out, null, 2), 'application/json');\n}\n\nfunction importJSON(ev) {\n  const file = ev.target.files?.[0];\n  if (!file) return;\n  const reader = new FileReader();\n  reader.onload = () => {\n    try {\n      const j = JSON.parse(reader.result);\n      let changed = false;\n      if (j && j.LOCATIONS) {\n        try {\n          localStorage.setItem(OVERRIDE_KEY, JSON.stringify(j.LOCATIONS));\n          RUNTIME_LOCATIONS = j.LOCATIONS;\n          changed = true;\n          toast('Locations dataset imported.');\n        } catch(e) {\n          console.warn('Failed to persist imported LOCATIONS', e);\n        }\n      }\n      if (j && j.state && j.state.dayMap) {\n        state.dayMap = j.state.dayMap;\n        changed = true;\n        toast('State imported.');\n      }\n      if (changed) renderAll();\n      else toast('JSON did not include expected fields.');\n    } catch(e) {\n      toast('Import failed.');\n    }\n  };\n  reader.readAsText(file);\n}\n\n// Bootstrap\n(async function init() {\n  setupControls();\n  await ensureEngine(state.mapMode);\n  renderAll();\n})();\n", "config": "// config.js \u2014 API key & app configuration helpers\nexport async function getGoogleMapsApiKey() {\n  // 1) Meta tag fallback\n  const meta = document.querySelector('meta[name=\"maps:apiKey\"]');\n  if (meta && meta.content) return meta.content.trim();\n\n  // 2) Pre-injected window global\n  if (window.__ENV && window.__ENV.GOOGLE_MAPS_API_KEY) return window.__ENV.GOOGLE_MAPS_API_KEY;\n\n  // 3) bundlers (Vite) inject into import.meta.env at build-time\n  try {\n    const maybe = import.meta && import.meta.env && import.meta.env.GOOGLE_MAPS_API_KEY;\n    if (maybe) return maybe;\n  } catch (e) {}\n\n  // 4) Attempt to fetch /env.json (if provided by server)\n  try {\n    const res = await fetch('/env.json', { cache: 'no-store' });\n    if (res.ok) {\n      const j = await res.json();\n      if (j && j.GOOGLE_MAPS_API_KEY) return j.GOOGLE_MAPS_API_KEY;\n    }\n  } catch (e) {}\n\n  console.warn('GOOGLE_MAPS_API_KEY is missing \u2014 Google mode may not load.');\n  return '';\n}\n\nexport const STORAGE = {\n  theme: 'NYCPhotoGuide:theme',\n  anchors: 'NYCPhotoGuide:anchors',\n  activeAnchor: 'NYCPhotoGuide:activeAnchor',\n  state: 'NYCPhotoGuide:state'\n};\n\nexport function saveLocal(k, v) {\n  try { localStorage.setItem(k, JSON.stringify(v)); } catch(e){ console.warn('saveLocal failed', e); }\n}\nexport function loadLocal(k, d) {\n  try {\n    const v = localStorage.getItem(k);\n    return v ? JSON.parse(v) : d;\n  } catch(e) { return d; }\n}\n\nexport function fmtTime(dt) {\n  if (!dt) return '\u2014';\n  try {\n    return (dt instanceof Date ? dt : new Date(dt)).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });\n  } catch(e) { return '\u2014'; }\n}\n\nexport function km(vMeters) { return (vMeters/1000).toFixed(2) + ' km'; }\nexport function minutes(vSecs) { return Math.round(vSecs/60) + ' min'; }\n\nexport const NYC = { lat: 40.7128, lon: -74.0060 };\n", "data/locations": "// data/locations.js \u2014 import JSON dataset and export as LOCATIONS\n// Uses JSON module assertions (modern browsers). If your static host disallows JSON module MIME,\n// you can replace this with a plain JS export of the array.\nimport DATA from './locations.json' assert { type: 'json' };\nexport const LOCATIONS = DATA;\n", "lib/googleLoader": "// lib/googleLoader.js \u2014 idempotent Promise-based Google Maps JS SDK loader\nlet _promise = null;\n\nexport function loadGoogleMaps(apiKey, libraries = ['places']) {\n  if (typeof window !== 'undefined' && window.google && window.google.maps) {\n    return Promise.resolve(window.google);\n  }\n  if (_promise) return _promise;\n  _promise = new Promise((resolve, reject) => {\n    if (!apiKey) {\n      console.warn('Google Maps API key missing.');\n    }\n    const cbName = '__googleMapsReady__' + Math.random().toString(36).slice(2);\n    window[cbName] = () => {\n      if (window.google && window.google.maps) {\n        resolve(window.google);\n      } else {\n        reject(new Error('Google Maps loaded but google.maps missing'));\n      }\n      // cleanup\n      try { delete window[cbName]; } catch(e){}\n    };\n    const s = document.createElement('script');\n    const libs = libraries && libraries.length ? '&libraries=' + libraries.join(',') : '';\n    s.src = \\`https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(apiKey||'')}${libs}&v=weekly&callback=${cbName}\\`;\n    s.async = true;\n    s.onerror = () => reject(new Error('Google Maps failed to load'));\n    document.head.appendChild(s);\n  });\n  return _promise;\n}\n", "lib/sunmoon": "// lib/sunmoon.js \u2014 lightweight solar times + moon illumination\n// NOTE: Times are approximate; sufficient for planning UI. Moonrise/set are coarse or may be unavailable (\u2014).\n\nconst rad = Math.PI / 180;\nfunction dayOfYear(d) {\n  const start = new Date(d.getFullYear(), 0, 0);\n  const diff = d - start + ((start.getTimezoneOffset() - d.getTimezoneOffset()) * 60 * 1000);\n  return Math.floor(diff / 86400000);\n}\n\n// Equation of time & declination using NOAA approximations\nfunction solarParams(date) {\n  const N = dayOfYear(date);                 // 1..366 (local time)\n  const gamma = 2 * Math.PI / 365 * (N - 1 + ((12 - 12) / 24)); // fractional year at local noon\n  const eqTime = 229.18 * (0.000075 + 0.001868 * Math.cos(gamma) - 0.032077 * Math.sin(gamma)\n                - 0.014615 * Math.cos(2*gamma) - 0.040849 * Math.sin(2*gamma)); // minutes\n  const decl = 0.006918 - 0.399912 * Math.cos(gamma) + 0.070257 * Math.sin(gamma)\n             - 0.006758 * Math.cos(2*gamma) + 0.000907 * Math.sin(2*gamma)\n             - 0.002697 * Math.cos(3*gamma) + 0.00148 * Math.sin(3*gamma); // radians\n  return { eqTime, decl };\n}\n\nfunction solarEvent(date, lat, lon, zenithDeg, isSunrise) {\n  // Returns Date in local time for sunrise/sunset-like events; null if no event that day\n  const { eqTime, decl } = solarParams(date);\n  const latitude = lat * rad;\n  const zenith = zenithDeg * rad; // 90.833: sunrise/set; 96: civil dawn/dusk\n  const ha = Math.acos(Math.min(1, Math.max(-1,\n    (Math.cos(zenith) / (Math.cos(latitude) * Math.cos(decl))) - Math.tan(latitude) * Math.tan(decl)\n  ))); // radians\n  if (isNaN(ha)) return null; // no sunrise/sunset at this latitude+date\n\n  const haDeg = ha / rad;\n  const minutesUTC = 720 - 4 * (lon + (isSunrise ? haDeg : -haDeg)) - (solarParams(date).eqTime);\n  // convert to local Date\n  const dt = new Date(date); dt.setHours(0,0,0,0);\n  const local = new Date(dt.getTime() + minutesUTC * 60000);\n  return local;\n}\n\n// Moon illumination \u2014 simple synodic cycle approximation\nfunction moonIllumination(date) {\n  const synodic = 29.530588853; // days\n  // reference new moon: 2000-01-06 18:14 UTC (JDN 2451550.1)\n  const ref = Date.UTC(2000, 0, 6, 18, 14, 0);\n  const phase = ((date.getTime() - ref) / 86400000) / synodic % 1;\n  const illum = 0.5 * (1 - Math.cos(2 * Math.PI * phase));\n  return { fraction: illum, phase };\n}\n\n// Coarse moonrise/moonset: not guaranteed. We sample altitude over the day using crude model.\n// If not reliable, return null to display '\u2014'.\nfunction moonRiseSet(date, lat, lon) {\n  try {\n    // Crude elevation sampling; if we detect a sign change in altitude, we mark rise/set.\n    // Using simplified lunar RA/Dec from Meeus-ish approximations (very rough).\n    const times = [];\n    const start = new Date(date); start.setHours(0,0,0,0);\n    const end = new Date(start.getTime() + 24*3600*1000);\n    let prevAlt = null, prevT = null;\n    let rise = null, setT = null;\n    for (let t = start.getTime(); t <= end.getTime(); t += 10*60*1000) { // every 10 minutes\n      const alt = lunarAltitude(new Date(t), lat, lon);\n      if (prevAlt != null) {\n        if (prevAlt < 0 && alt >= 0 && !rise) {\n          rise = new Date(t - 5*60*1000); // rough\n        } else if (prevAlt >= 0 && alt < 0 && !setT) {\n          setT = new Date(t - 5*60*1000);\n        }\n      }\n      prevAlt = alt; prevT = t;\n      if (rise && setT) break;\n    }\n    return { rise: rise || null, set: setT || null };\n  } catch(e) {\n    return { rise: null, set: null };\n  }\n}\n\n// Very rough lunar altitude \u2014 adequate for detecting crossings in NYC latitudes\nfunction lunarAltitude(date, lat, lon) {\n  // Based on simplified algorithms; not for precise navigation.\n  const d = (date - new Date(Date.UTC(2000, 0, 1, 12))) / 86400000; // days since J2000\n  // Moon's mean longitude, mean anomaly, argument of latitude (deg)\n  const L = (218.316 + 13.176396 * d) % 360;\n  const M = (134.963 + 13.064993 * d) % 360;\n  const F = (93.272 + 13.229350 * d) % 360;\n  // Ecliptic longitude and latitude (deg) \u2014 simplified\n  const lonEcl = L + 6.289 * Math.sin(M * rad);\n  const latEcl = 5.128 * Math.sin(F * rad);\n\n  const e = 23.4397 * rad; // obliquity\n  const l = lonEcl * rad, b = latEcl * rad;\n\n  // Convert to RA/Dec\n  const sinDec = Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(l);\n  const dec = Math.asin(sinDec);\n  const ra = Math.atan2(Math.sin(l) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(l));\n\n  // Sidereal time\n  const lw = -lon * rad;\n  const GMST = 280.16 + 360.9856235 * d;\n  const sid = (GMST * rad + lw) % (2*Math.PI);\n  const H = (sid - ra); // hour angle\n\n  // Altitude\n  const phi = lat * rad;\n  const alt = Math.asin(Math.sin(phi) * Math.sin(dec) + Math.cos(phi) * Math.cos(dec) * Math.cos(H));\n  // Approx atmospheric refraction correction could be applied, but unnecessary here\n  return alt;\n}\n\nexport function computeLightAndMoon(date, lat, lon) {\n  // Civil twilight: 96\u00b0, sunrise/sunset: 90.833\u00b0\n  const dawn = solarEvent(date, lat, lon, 96, true);\n  const sunrise = solarEvent(date, lat, lon, 90.833, true);\n  const sunset = solarEvent(date, lat, lon, 90.833, false);\n  const dusk = solarEvent(date, lat, lon, 96, false);\n  const illum = moonIllumination(date);\n  const mrs = moonRiseSet(date, lat, lon);\n\n  return {\n    dawn, sunrise, sunset, dusk,\n    moonrise: mrs.rise, moonset: mrs.set,\n    illum: illum.fraction\n  };\n}\n", "map-google": "// map-google.js \u2014 Google Maps engine\nimport { loadGoogleMaps } from 'lib/googleLoader';\nimport { NYC } from './config.js';\n\nconst COLORS = {\n  Morning: getComputedStyle(document.documentElement).getPropertyValue('--morning') || '#f59e0b',\n  Afternoon: getComputedStyle(document.documentElement).getPropertyValue('--afternoon') || '#2563eb',\n  Evening: getComputedStyle(document.documentElement).getPropertyValue('--evening') || '#7c3aed',\n  Night: getComputedStyle(document.documentElement).getPropertyValue('--night') || '#334155',\n  Micro: getComputedStyle(document.documentElement).getPropertyValue('--micro') || '#0d9488'\n};\n\nexport class GoogleMapEngine {\n  constructor(container, apiKey) {\n    this.container = container;\n    this.apiKey = apiKey;\n    this.map = null;\n    this.markers = [];\n    this.overlays = [];\n    this.dirs = null;\n    this.dirRenderer = null;\n  }\n\n  async init() {\n    const google = await loadGoogleMaps(this.apiKey, ['places']);\n    this.map = new google.maps.Map(this.container, {\n      center: { lat: NYC.lat, lng: NYC.lon },\n      zoom: 12,\n      disableDefaultUI: false,\n      mapTypeControl: false,\n      streetViewControl: true,\n      fullscreenControl: false,\n      clickableIcons: true\n    });\n    this.dirs = new google.maps.DirectionsService();\n    this.dirRenderer = new google.maps.DirectionsRenderer({ map: this.map, suppressMarkers: true });\n    return this;\n  }\n\n  clear() {\n    for (const m of this.markers) { m.setMap(null); }\n    for (const o of this.overlays) { o.setMap && o.setMap(null); }\n    this.markers = [];\n    this.overlays = [];\n    if (this.dirRenderer) this.dirRenderer.set('directions', null);\n  }\n\n  // Compute absolute micro pin lat/lng from anchor + r/bearing (degrees)\n  static microFrom(anchor, micro) {\n    const bearing = (micro.bearing || 0) * Math.PI / 180;\n    const lat = anchor.lat;\n    const dlat = (micro.r * Math.cos(bearing)) / 111111;\n    const dlon = (micro.r * Math.sin(bearing)) / (111111 * Math.cos(lat * Math.PI/180));\n    return { lat: lat + dlat, lon: anchor.lon + dlon };\n  }\n\n  render(locations) {\n    if (!this.map) return;\n    this.clear();\n    const google = window.google;\n    const bounds = new google.maps.LatLngBounds();\n    for (const loc of locations) {\n      const a = loc.anchors[loc.activeAnchor || 0] || loc.anchors[0];\n      const pos = { lat: a.lat, lng: a.lon };\n      const col = (COLORS[loc.block] || '#999').trim() || '#999';\n\n      const m = new google.maps.Marker({\n        position: pos,\n        map: this.map,\n        title: loc.name,\n        icon: {\n          path: google.maps.SymbolPath.CIRCLE,\n          scale: 6,\n          fillColor: col, fillOpacity: 1,\n          strokeColor: '#ffffff', strokeWeight: 1\n        }\n      });\n      this.markers.push(m);\n      bounds.extend(pos);\n\n      // Micro pins + arrows\n      for (const micro of loc.micro || []) {\n        const mp = GoogleMapEngine.microFrom({ lat: a.lat, lon: a.lon }, micro);\n        const mpos = { lat: mp.lat, lng: mp.lon };\n        const mm = new google.maps.Marker({\n          position: mpos,\n          map: this.map,\n          title: \\`${loc.name} \u2014 ${micro.title}\\`,\n          icon: {\n            path: google.maps.SymbolPath.CIRCLE,\n            scale: 4,\n            fillColor: COLORS.Micro.trim(), fillOpacity: 1,\n            strokeColor: '#fff', strokeWeight: 1\n          }\n        });\n        this.markers.push(mm);\n        bounds.extend(mpos);\n\n        // Arrow line (20m)\n        const arrowLen = 20;\n        const br = (micro.bearing || 0) * Math.PI/180;\n        const endLat = mp.lat + (arrowLen * Math.cos(br)) / 111111;\n        const endLon = mp.lon + (arrowLen * Math.sin(br)) / (111111 * Math.cos(mp.lat * Math.PI/180));\n        const pl = new google.maps.Polyline({\n          path: [mpos, { lat: endLat, lng: endLon }],\n          map: this.map,\n          strokeColor: COLORS.Micro.trim(),\n          strokeWeight: 2,\n          icons: [{\n            icon: { path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW },\n            offset: '100%'\n          }]\n        });\n        this.overlays.push(pl);\n      }\n    }\n    if (!bounds.isEmpty()) this.map.fitBounds(bounds, { top:40, bottom:40, left:40, right:40 });\n  }\n\n  fitToLocation(loc) {\n    const google = window.google;\n    const a = loc.anchors[loc.activeAnchor || 0] || loc.anchors[0];\n    const b = new google.maps.LatLngBounds();\n    b.extend({ lat: a.lat, lng: a.lon });\n    for (const micro of loc.micro || []) {\n      const mp = GoogleMapEngine.microFrom({ lat: a.lat, lon: a.lon }, micro);\n      b.extend({ lat: mp.lat, lng: mp.lon });\n    }\n    this.map.fitBounds(b, { top:40, bottom:40, left:40, right:40 });\n  }\n\n  async drawRoute(from, to) {\n    if (!this.dirs || !this.dirRenderer) return;\n    const google = window.google;\n    return new Promise((resolve, reject) => {\n      this.dirs.route({\n        origin: new google.maps.LatLng(from.lat, from.lon),\n        destination: new google.maps.LatLng(to.lat, to.lon),\n        travelMode: google.maps.TravelMode.WALKING\n      }, (res, status) => {\n        if (status === 'OK' && res) {\n          this.dirRenderer.setDirections(res);\n          resolve(res);\n        } else {\n          reject(new Error('Directions failed: ' + status));\n        }\n      });\n    });\n  }\n}\n", "map-leaflet": "// map-leaflet.js \u2014 Leaflet engine (ESM from CDN)\nimport { NYC } from './config.js';\n\nconst TILE_URL = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n\nexport class LeafletMapEngine {\n  constructor(container) {\n    this.container = container;\n    this.map = null;\n    this.layerGroup = null;\n    this.L = null;\n  }\n\n  async init() {\n    // Load ESM build of Leaflet dynamically\n    this.L = await import('https://unpkg.com/leaflet@1.9.4/dist/leaflet-src.esm.js');\n    const L = this.L;\n    this.map = L.map(this.container, { center: [NYC.lat, NYC.lon], zoom: 12, preferCanvas: true });\n    L.tileLayer(TILE_URL, {\n      attribution: '&copy; OpenStreetMap contributors'\n    }).addTo(this.map);\n    this.layerGroup = L.layerGroup().addTo(this.map);\n    return this;\n  }\n\n  clear() {\n    if (this.layerGroup) this.layerGroup.clearLayers();\n  }\n\n  static microFrom(anchor, micro) {\n    const bearing = (micro.bearing || 0) * Math.PI / 180;\n    const lat = anchor.lat;\n    const dlat = (micro.r * Math.cos(bearing)) / 111111;\n    const dlon = (micro.r * Math.sin(bearing)) / (111111 * Math.cos(lat * Math.PI/180));\n    return { lat: lat + dlat, lon: anchor.lon + dlon };\n  }\n\n  render(locations) {\n    const L = this.L;\n    this.clear();\n    let b = null;\n    for (const loc of locations) {\n      const a = loc.anchors[loc.activeAnchor || 0] || loc.anchors[0];\n      const col = getComputedStyle(document.documentElement).getPropertyValue(\n        '--' + (loc.block.toLowerCase())\n      ).trim() || '#999';\n      const anchorM = L.circleMarker([a.lat, a.lon], { radius: 6, color: '#fff', weight:1, fillColor: col, fillOpacity: 1 });\n      anchorM.addTo(this.layerGroup).bindTooltip(loc.name);\n      b = b || L.latLngBounds([a.lat, a.lon], [a.lat, a.lon]);\n      b.extend([a.lat, a.lon]);\n\n      for (const micro of loc.micro || []) {\n        const mp = LeafletMapEngine.microFrom({ lat: a.lat, lon: a.lon }, micro);\n        const mm = L.circleMarker([mp.lat, mp.lon], { radius: 4, color: '#fff', weight:1, fillColor: getComputedStyle(document.documentElement).getPropertyValue('--micro').trim() || '#0d9488', fillOpacity:1 });\n        mm.addTo(this.layerGroup).bindTooltip(micro.title);\n\n        // Arrow (20m)\n        const arrowLen = 20;\n        const br = (micro.bearing || 0) * Math.PI/180;\n        const endLat = mp.lat + (arrowLen * Math.cos(br)) / 111111;\n        const endLon = mp.lon + (arrowLen * Math.sin(br)) / (111111 * Math.cos(mp.lat * Math.PI/180));\n        L.polyline([[mp.lat, mp.lon], [endLat, endLon]], { color: getComputedStyle(document.documentElement).getPropertyValue('--micro').trim(), weight: 2 }).addTo(this.layerGroup);\n        b.extend([mp.lat, mp.lon]);\n        b.extend([endLat, endLon]);\n      }\n    }\n    if (b) this.map.fitBounds(b.pad(0.15));\n  }\n\n  fitToLocation(loc) {\n    const L = this.L;\n    const a = loc.anchors[loc.activeAnchor || 0] || loc.anchors[0];\n    let b = L.latLngBounds([a.lat, a.lon], [a.lat, a.lon]);\n    for (const micro of loc.micro || []) {\n      const mp = LeafletMapEngine.microFrom({ lat: a.lat, lon: a.lon }, micro);\n      b.extend([mp.lat, mp.lon]);\n    }\n    this.map.fitBounds(b.pad(0.15));\n  }\n\n  async drawRoute(from, to) {\n    // Not supported in Leaflet engine in this minimal build\n    throw new Error('Route drawing is supported in Google mode only.');\n  }\n}\n"};
const urls = Object.fromEntries(Object.entries(MODULES).map(([name, code]) => {
  const blob = new Blob([code], { type: 'text/javascript' });
  return [name, URL.createObjectURL(blob)];
}));

// Create import map
const im = document.createElement('script');
im.type = 'importmap';
im.textContent = JSON.stringify({ imports: urls });
document.head.appendChild(im);

// Import the app after the import map is parsed
Promise.resolve().then(() => import('app'));
</script>
</body>
</html>
