<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NYC Photo Guide</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-zL8M9D9Rt0GvQ7vC18JNpDutZCRa14Qdqg+3GkN0wYg="
    crossorigin=""
  />
  <script
    src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-o9N1j7kGStG3MZ8v+DnUE7aO7mG3oGJ4E1qf0y4bPmA="
    crossorigin=""
    defer
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.js" defer></script>
  <style>
    :root {
      color-scheme: dark;
      --bg: #090b11;
      --bg-elevated: #10131c;
      --bg-panel: #151927;
      --bg-hover: rgba(255, 255, 255, 0.04);
      --fg: #f4f6ff;
      --fg-muted: #b6b9c9;
      --accent: #5b8def;
      --accent-soft: rgba(91, 141, 239, 0.2);
      --danger: #ff6b6b;
      --success: #4ecdc4;
      --font: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --radius: 16px;
      --border: rgba(255, 255, 255, 0.08);
      --shadow: 0 24px 70px rgba(0, 0, 0, 0.4);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font);
      background: radial-gradient(circle at 20% -10%, rgba(91, 141, 239, 0.12), transparent 55%),
        radial-gradient(circle at 80% -30%, rgba(148, 94, 255, 0.18), transparent 60%),
        var(--bg);
      color: var(--fg);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(18px);
      background: rgba(9, 11, 17, 0.82);
      border-bottom: 1px solid var(--border);
      padding: 16px 24px 22px;
    }

    h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    .header-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--fg-muted);
      font-size: 13px;
    }

    .header-meta span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 18px;
      margin-top: 20px;
    }

    .controls-grid label {
      display: flex;
      flex-direction: column;
      font-size: 12px;
      gap: 6px;
      color: var(--fg-muted);
      letter-spacing: 0.02em;
    }

    .dual-slider {
      display: grid;
      gap: 6px;
    }

    .dual-slider input[type='range'] {
      width: 100%;
    }

    .dual-slider span {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.6);
      letter-spacing: 0.02em;
    }

    input,
    select,
    button,
    textarea {
      font: inherit;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--bg-panel);
      color: var(--fg);
      padding: 10px 12px;
      transition: border-color 0.2s, background 0.2s;
    }

    input:focus,
    select:focus,
    button:focus,
    textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-soft);
    }

    button {
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      background: linear-gradient(135deg, rgba(91, 141, 239, 0.15), rgba(91, 141, 239, 0.05));
    }

    button:hover {
      background: linear-gradient(135deg, rgba(91, 141, 239, 0.25), rgba(91, 141, 239, 0.1));
    }

    main {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 24px;
      padding: 0 24px 24px;
      flex: 1;
    }

    .app-shell {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 24px;
      align-items: flex-start;
    }

    .light-panels,
    .map-panel,
    .location-stream {
      background: rgba(16, 19, 28, 0.72);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 22px;
      box-shadow: var(--shadow);
    }

    .map-panel {
      position: sticky;
      top: 112px;
      min-height: 520px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .map-tabs {
      display: inline-flex;
      align-self: flex-start;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 14px;
      padding: 4px;
      border: 1px solid var(--border);
      gap: 4px;
    }

    .map-tabs button {
      border-radius: 10px;
      padding: 8px 16px;
      font-size: 13px;
      background: transparent;
      border: none;
    }

    .map-tabs button.active {
      background: rgba(91, 141, 239, 0.24);
      color: #fff;
      box-shadow: inset 0 0 0 1px rgba(91, 141, 239, 0.6);
    }

    .map-canvas {
      flex: 1;
      min-height: 420px;
      border-radius: 14px;
      overflow: hidden;
      background: rgba(10, 12, 18, 0.6);
    }

    .light-panels h2,
    .location-stream h2 {
      margin: 0 0 18px;
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--fg-muted);
    }

    .light-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }

    .light-card {
      padding: 14px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 92px;
    }

    .light-card span {
      font-size: 13px;
      color: var(--fg-muted);
    }

    .light-card strong {
      font-size: 18px;
      font-weight: 600;
    }

    .location-stream {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .location-card {
      padding: 24px;
      border-radius: 18px;
      background: rgba(12, 15, 24, 0.88);
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.42);
      transition: transform 0.25s ease, border-color 0.25s ease;
    }

    .location-card:hover {
      transform: translateY(-4px);
      border-color: rgba(91, 141, 239, 0.45);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      margin-bottom: 16px;
    }

    .card-title {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .card-title h3 {
      margin: 0;
      font-size: 20px;
    }

    .card-subtitle {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 10px;
      color: var(--fg-muted);
      font-size: 13px;
    }

    .badge {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.05);
      font-size: 12px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 16px;
      margin-bottom: 18px;
    }

    .summary-item {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .summary-item span {
      font-size: 12px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--fg-muted);
    }

    .summary-item strong {
      font-size: 15px;
      font-weight: 500;
    }

    .card-actions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
      margin-bottom: 22px;
    }

    .card-actions button {
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.04);
      font-size: 13px;
      padding: 10px 12px;
    }

    .pill-group {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 18px;
    }

    .pill {
      padding: 10px 16px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(22, 24, 34, 0.88);
      display: inline-flex;
      gap: 8px;
      align-items: center;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.2s, background 0.2s;
      text-decoration: none;
      color: inherit;
    }

    .pill:hover {
      transform: translateY(-2px);
      background: rgba(255, 255, 255, 0.08);
    }

    .pill.active {
      background: rgba(91, 141, 239, 0.24);
      border-color: rgba(91, 141, 239, 0.8);
      box-shadow: 0 12px 32px rgba(91, 141, 239, 0.18);
    }

    details {
      background: rgba(12, 14, 20, 0.72);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 18px;
    }

    summary {
      list-style: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      cursor: pointer;
      font-weight: 600;
    }

    summary::marker {
      display: none;
    }

    summary span {
      color: var(--fg-muted);
      font-size: 13px;
      font-weight: 400;
    }

    .detail-grid {
      margin-top: 18px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
    }

    .detail-card {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .detail-card h4 {
      margin: 0 0 10px;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--fg-muted);
    }

    .detail-card ul {
      margin: 0;
      padding-left: 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .detail-card li {
      font-size: 13px;
      line-height: 1.5;
      color: rgba(244, 246, 255, 0.86);
    }

    .reference-images {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 12px;
      margin-top: 14px;
    }

    .reference-images img {
      width: 100%;
      aspect-ratio: 4 / 3;
      object-fit: cover;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(10, 12, 18, 0.8);
    }

    .chip-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .chip {
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.05);
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
    }

    .chip.active {
      background: rgba(91, 141, 239, 0.24);
      border-color: rgba(91, 141, 239, 0.65);
      color: #fff;
      box-shadow: 0 10px 28px rgba(91, 141, 239, 0.2);
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 20px;
    }

    .toast-container {
      position: fixed;
      bottom: 24px;
      right: 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 30;
    }

    .toast {
      padding: 14px 18px;
      border-radius: 12px;
      background: rgba(15, 18, 28, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
      font-size: 14px;
      transition: opacity 0.4s ease, transform 0.4s ease;
    }

    .empty-state {
      padding: 60px 24px;
      text-align: center;
      color: var(--fg-muted);
      border: 1px dashed rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      background: rgba(12, 14, 20, 0.6);
    }

    .empty-state strong {
      display: block;
      color: #fff;
      margin-top: 12px;
      font-size: 16px;
    }

    @media (max-width: 1200px) {
      main {
        grid-template-columns: 1fr;
      }

      .app-shell {
        grid-template-columns: 1fr;
      }

      .map-panel {
        position: static;
      }
    }

    @media (max-width: 900px) {
      header {
        padding: 14px 18px;
      }

      main {
        padding: 0 18px 18px;
      }

      .app-shell {
        gap: 18px;
      }
    }

    @media (max-width: 640px) {
      .controls-grid {
        grid-template-columns: 1fr;
      }

      .card-actions {
        grid-template-columns: 1fr;
      }

      .pill-group {
        gap: 8px;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-top">
      <h1>NYC Photo Guide</h1>
      <div class="header-meta">
        <span>Dark Skyline Edition</span>
        <span>Updated: <time id="header-date"></time></span>
      </div>
    </div>
    <div class="controls-grid" id="control-panel"></div>
  </header>
  <main>
    <section class="light-panels" id="light-panels"></section>
    <section class="app-shell">
      <div class="location-stream" id="location-stream"></div>
      <div class="map-panel" id="map-panel">
        <div class="map-tabs" id="map-tabs"></div>
        <div id="map-google" class="map-canvas" hidden></div>
        <div id="map-leaflet" class="map-canvas" hidden></div>
      </div>
    </section>
  </main>
  <input type="file" id="import-json" accept="application/json" hidden />
  <template id="location-card-template">
    <article class="location-card"></article>
  </template>
  <div class="toast-container" id="toast-container"></div>
  <script type="module">
    const GOOGLE_MAPS_KEY = 'AIzaSyDsq2ztFeFfmgqiRIZZtK5R7aCVGF66-80';
    const NOAA_ENDPOINT = 'https://api.tidesandcurrents.noaa.gov/api/prod/datagetter';
    const LOCAL_STORAGE_KEY = 'nyc-photo-guide-state-v1';
    const BLOCKS = ['Morning', 'Afternoon', 'Evening', 'Night'];

    const elements = {
      controlPanel: document.getElementById('control-panel'),
      lightPanels: document.getElementById('light-panels'),
      locationStream: document.getElementById('location-stream'),
      mapTabs: document.getElementById('map-tabs'),
      mapGoogle: document.getElementById('map-google'),
      mapLeaflet: document.getElementById('map-leaflet'),
      toastContainer: document.getElementById('toast-container'),
      importInput: document.getElementById('import-json'),
    };

    const state = {
      locations: [],
      filtered: [],
      filters: {
        dayA: null,
        dayB: null,
        activeDays: new Set(),
        blocks: new Set(BLOCKS),
        rankMin: 1,
        rankMax: 5,
        search: '',
        proOnly: false,
        rainPlan: false,
        windSafe: false,
      },
      expandedCards: new Set(),
      anchorOverrides: {},
      tides: {},
      dayMap: {},
      mapMode: 'leaflet',
      theme: 'dark',
      google: {
        map: null,
        markers: [],
        scriptLoaded: false,
        directionsService: null,
        directionsRenderer: null,
        distanceMatrix: null,
        placesService: null,
      },
      leaflet: {
        map: null,
        anchorLayer: null,
        microLayer: null,
        routeLayer: null,
      },
      referenceCache: {},
    };

    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('header-date').textContent = new Date().toLocaleDateString();

      init().catch((error) => {
        console.error('Failed to initialize app', error);
        showToast('Unable to start the app. Check console for details.', 'error');
      });
    });

    async function init() {
      try {
        console.log('Starting app initialization...');
        applyPersistedState();
        console.log('Applied persisted state');
        
        await loadLocations();
        console.log('Loaded locations data');
        
        ensureDefaultDates();
        console.log('Set default dates');
        
        renderControlPanel();
        console.log('Rendered control panel');
        
        renderMapTabs();
        console.log('Rendered map tabs');
        
        setupImportHandler();
        console.log('Set up import handler');
        
        updateLightPanels();
        console.log('Updated light panels');
        
        applyFilters();
      try {
        console.log('Initializing Leaflet map...');
        await ensureLeafletMap();
        console.log('Leaflet map initialized');
      } catch (error) {
        console.error('Leaflet failed to initialize', error);
        showToast('Leaflet map unavailable.', 'error');
      }

      if (state.mapMode === 'google') {
        try {
          console.log('Initializing Google Maps...');
          await ensureGoogleMap();
          console.log('Google Maps initialized');
        } catch (error) {
          console.error('Google Maps failed to initialize', error);
          showToast('Google Maps failed. Falling back to Leaflet.', 'error');
          state.mapMode = 'leaflet';
          updateMapVisibility();
        }
      }

      console.log('Rendering locations...');
      renderLocations();
      console.log('Updating map markers...');
      updateMapMarkers();
      console.log('Persisting state...');
      persistState();
      console.log('App initialization complete!');
    } catch (error) {
      console.error('Init failed:', error);
      showToast('App initialization failed. Check console for details.', 'error');
    }
  }
        }
      }

      renderLocations();
      updateMapMarkers();
      persistState();
    }

    async function loadLocations() {
      const response = await fetch('locations.json');
      if (!response.ok) throw new Error('Failed to load locations dataset');
      const data = await response.json();
      state.locations = data;
    }

    function ensureDefaultDates() {
      const uniqueDays = Array.from(new Set(state.locations.map((loc) => loc.day))).sort();
      state.filters.dayA = state.filters.dayA || uniqueDays[0];
      state.filters.dayB = state.filters.dayB || uniqueDays[1] || uniqueDays[0];
      state.filters.activeDays = new Set([
        state.filters.dayA,
        state.filters.dayB,
      ].filter(Boolean));
    }

    function applyFilters() {
      const { rankMin, rankMax, search, activeDays, blocks } = state.filters;
      const normalizedSearch = search.trim().toLowerCase();
      state.filtered = state.locations.filter((location) => {
        if (!activeDays.has(location.day)) return false;
        if (!blocks.has(location.block)) return false;
        if (location.rank < rankMin || location.rank > rankMax) return false;
        if (!normalizedSearch) return true;
        const haystack = [
          location.name,
          location.whyNow,
          location.gear,
          location.bearing,
          location.settings,
          ...location.pins.map((p) => `${p.title} ${p.detail}`),
          ...location.shots.map((s) => `${s.title} ${s.detail}`),
        ]
          .join(' ')
          .toLowerCase();
        return haystack.includes(normalizedSearch);
      });
    }

    function renderLocations() {
      elements.locationStream.innerHTML = '';
      if (!state.filtered.length) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.innerHTML = '<strong>No locations match your filters.</strong><br/>Try broadening your search or rank range.';
        elements.locationStream.append(empty);
        return;
      }
      const fragment = document.createDocumentFragment();
      const template = document.getElementById('location-card-template');
      state.filtered
        .slice()
        .sort((a, b) => a.rank - b.rank)
        .forEach((location) => {
          const instance = template.content.firstElementChild.cloneNode(true);
          buildLocationCard(instance, location);
          fragment.append(instance);
        });
      elements.locationStream.append(fragment);
    }

    function buildLocationCard(card, location) {
      card.className = 'location-card';
      card.dataset.id = location.id;
      card.innerHTML = createLocationCardMarkup(location);
      attachCardHandlers(card, location);
    }

    function createLocationCardMarkup(location) {
      const anchorIndex = getActiveAnchorIndex(location);
      const anchor = location.anchors[anchorIndex];
      const microPins = location.micro.map((micro) => ({
        ...micro,
        coords: computeMicroPin(anchor, micro),
      }));
      const pinsList = location.pins.map((pin) => `<li><strong>${pin.title}:</strong> ${pin.detail}</li>`).join('');
      const shotsList = location.shots.map((shot) => `<li><strong>${shot.title}:</strong> ${shot.detail}</li>`).join('');

      return `
        <header class="card-header">
          <div class="card-title">
            <h3>${location.name}</h3>
            <div class="card-subtitle">
              <span>${formatDayLabel(location.day)}</span>
              <span>${location.block}</span>
              <span>${location.bearing}</span>
            </div>
          </div>
          <div class="badge">#${location.rank}</div>
        </header>
        <div class="summary-grid">
          <div class="summary-item"><span>Why now</span><strong>${location.whyNow}</strong></div>
          <div class="summary-item"><span>Gear</span><strong>${location.gear}</strong></div>
          <div class="summary-item"><span>Settings</span><strong>${location.settings}</strong></div>
        </div>
        <div class="card-actions">
          <button data-action="show-map">Show on map</button>
          <button data-action="eta">ETA</button>
          <button data-action="route">Route</button>
          <button data-action="open-anchor">Open (anchor)</button>
          <button data-action="walk-anchor">Walk to anchor</button>
        </div>
        <div class="pill-group" data-group="anchors">
          ${location.anchors
            .map((anchorOption, index) => `
              <button class="pill ${index === anchorIndex ? 'active' : ''}" data-anchor="${index}">
                ${anchorOption.label}
              </button>`)
            .join('')}
        </div>
        <div class="pill-group" data-group="micros">
          ${microPins
            .map((micro, index) => `
              <a class="pill" data-micro="${index}" href="${createDirectionsLink(micro.coords)}" target="_blank" rel="noopener">
                ${micro.title}
              </a>`)
            .join('')}
        </div>
        <details ${state.expandedCards.has(location.id) ? 'open' : ''}>
          <summary>
            Details
            <span>Pins, shot list, tides, moon, address, reference images</span>
          </summary>
          <div class="detail-grid">
            <div class="detail-card"><h4>Pins</h4><ul>${pinsList}</ul></div>
            <div class="detail-card"><h4>Shots</h4><ul>${shotsList}</ul></div>
            <div class="detail-card" data-section="tides"><h4>Tides</h4><div>${renderTideInfo(location.day)}</div></div>
            <div class="detail-card" data-section="moon"><h4>Moon</h4><div>${renderMoonInfo(location.day)}</div></div>
            <div class="detail-card" data-section="address"><h4>Address</h4><div data-address>Fetching...</div></div>
            <div class="detail-card" data-section="photos">
              <h4>Reference Images</h4>
              <button data-action="load-photos">Load reference images</button>
              <div class="reference-images" hidden></div>
            </div>
          </div>
        </details>
      `;
    }

    function attachCardHandlers(card, location) {
      card.querySelectorAll('[data-action]').forEach((button) => {
        button.addEventListener('click', (event) => handleCardAction(event, location));
      });

      const anchorGroup = card.querySelector('[data-group="anchors"]');
      anchorGroup.addEventListener('click', (event) => {
        if (!(event.target instanceof HTMLElement)) return;
        const button = event.target.closest('button[data-anchor]');
        if (!button) return;
        const index = Number(button.dataset.anchor);
        setActiveAnchor(location, index);
        renderLocations();
        updateMapMarkers();
      });

      const details = card.querySelector('details');
      details.addEventListener('toggle', () => {
        if (details.open) state.expandedCards.add(location.id);
        else state.expandedCards.delete(location.id);
        persistState();
      });

      performReverseGeocode(card, location);
    }

    function handleCardAction(event, location) {
      const action = event.currentTarget.dataset.action;
      if (!action) return;
      event.preventDefault();

      switch (action) {
        case 'show-map':
          focusLocationOnMap(location);
          break;
        case 'eta':
          requestEta(location);
          break;
        case 'route':
          requestRoute(location);
          break;
        case 'open-anchor':
          openAnchorInMaps(location);
          break;
        case 'walk-anchor':
          openAnchorDirections(location);
          break;
        case 'load-photos':
          loadReferenceImages(event.currentTarget, location);
          break;
        default:
          console.warn('Unhandled action', action);
      }
    }

    function getActiveAnchorIndex(location) {
      const override = state.anchorOverrides[location.id];
      if (typeof override === 'number' && location.anchors[override]) return override;
      return location.activeAnchor ?? 0;
    }

    function setActiveAnchor(location, index) {
      state.anchorOverrides[location.id] = index;
      persistState();
    }

    function computeMicroPin(anchor, micro) {
      const { lat, lon } = anchor;
      const radians = (micro.bearing * Math.PI) / 180;
      const dLat = (micro.r * Math.cos(radians)) / 111111;
      const dLon = (micro.r * Math.sin(radians)) / (111111 * Math.cos((lat * Math.PI) / 180));
      return {
        lat: lat + dLat,
        lon: lon + dLon,
      };
    }

    function createDirectionsLink(coords) {
      return `https://www.google.com/maps/dir/?api=1&destination=${coords.lat},${coords.lon}&travelmode=walking`;
    }

    function formatDayLabel(day) {
      const date = new Date(day + 'T00:00:00');
      return date.toLocaleDateString(undefined, {
        weekday: 'short',
        month: 'short',
        day: 'numeric',
      });
    }

    function renderTideInfo(day) {
      const entry = state.dayMap[day];
      if (!entry || !entry.tides) {
        fetchTidesForDay(day).catch((error) => {
          console.error('Tides fetch failed', error);
        });
        return '<em>Fetching tides...</em>';
      }
      if (entry.tides.error) {
        return `<em>${entry.tides.error}</em>`;
      }
      return entry.tides.values
        .map((tide) => {
          const time = new Date(tide.t).toLocaleTimeString([], {
            hour: 'numeric',
            minute: '2-digit',
          });
          return `<div>${tide.type} — ${tide.v} ft at ${time}</div>`;
        })
        .join('');
    }

    function renderMoonInfo(day) {
      const entry = state.dayMap[day];
      if (!entry || !entry.moon) {
        computeLightForDay(day);
        return '<em>Computing moon data...</em>';
      }
      const { moon } = entry;
      const rise = moon.rise ? formatTime(moon.rise) : '—';
      const set = moon.set ? formatTime(moon.set) : '—';
      const illumination = moon.illumination ? `${Math.round(moon.illumination * 100)}%` : '—';
      return `<div>Rise: ${rise}</div><div>Set: ${set}</div><div>Illumination: ${illumination}</div>`;
    }

    function formatTime(date) {
      return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
    }

    async function performReverseGeocode(card, location) {
      const addressDiv = card.querySelector('[data-address]');
      if (!addressDiv) return;

      const anchorIndex = getActiveAnchorIndex(location);
      const anchor = location.anchors[anchorIndex];
      const cacheKey = `${anchor.lat.toFixed(5)},${anchor.lon.toFixed(5)}`;
      if (state.dayMap[cacheKey]?.address) {
        addressDiv.textContent = state.dayMap[cacheKey].address;
        return;
      }

      try {
        const url = new URL('https://maps.googleapis.com/maps/api/geocode/json');
        url.searchParams.set('latlng', `${anchor.lat},${anchor.lon}`);
        url.searchParams.set('key', GOOGLE_MAPS_KEY);
        const response = await fetch(url.toString());
        if (!response.ok) throw new Error('Geocode request failed');
        const data = await response.json();
        const address = data.results?.[0]?.formatted_address ?? 'Address unavailable';
        addressDiv.textContent = address;
        state.dayMap[cacheKey] = state.dayMap[cacheKey] || {};
        state.dayMap[cacheKey].address = address;
        persistState();
      } catch (error) {
        console.error('Reverse geocode failed', error);
        addressDiv.textContent = 'Address unavailable';
      }
    }

    async function fetchTidesForDay(day) {
      if (state.dayMap[day]?.tides) return state.dayMap[day].tides;
      try {
        const start = day.replace(/-/g, '');
        const params = new URLSearchParams({
          product: 'predictions',
          begin_date: start,
          end_date: start,
          datum: 'MLLW',
          station: '8518750',
          time_zone: 'lst_ldt',
          interval: 'hilo',
          units: 'english',
          format: 'json',
        });
        const response = await fetch(`${NOAA_ENDPOINT}?${params.toString()}`);
        if (!response.ok) throw new Error('NOAA tides failed');
        const data = await response.json();
        const result = data.predictions ? { values: data.predictions } : { error: 'Tides unavailable' };
        state.dayMap[day] = state.dayMap[day] || {};
        state.dayMap[day].tides = result;
        persistState();
        renderLocations();
        return result;
      } catch (error) {
        console.error('Tides fetch error', error);
        const fallback = { error: 'Open NOAA high/low' };
        state.dayMap[day] = state.dayMap[day] || {};
        state.dayMap[day].tides = fallback;
        renderLocations();
        return fallback;
      }
    }

    function computeLightForDay(day) {
      if (state.dayMap[day]?.light && state.dayMap[day]?.moon) return;
      const date = new Date(day + 'T00:00:00');
      const lat = 40.7128;
      const lon = -74.006;
      const sunTimes = SunCalc.getTimes(date, lat, lon);
      const moonTimes = SunCalc.getMoonTimes(date, lat, lon, true);
      const moonIllum = SunCalc.getMoonIllumination(date);

      state.dayMap[day] = state.dayMap[day] || {};
      state.dayMap[day].light = {
        dawn: sunTimes.dawn,
        sunrise: sunTimes.sunrise,
        sunset: sunTimes.sunset,
        dusk: sunTimes.dusk,
      };
      state.dayMap[day].moon = {
        rise: moonTimes.rise ? new Date(moonTimes.rise) : null,
        set: moonTimes.set ? new Date(moonTimes.set) : null,
        illumination: moonIllum.fraction,
      };
      persistState();
    }

    function updateLightPanels() {
      const panel = elements.lightPanels;
      panel.innerHTML = '';
      const days = Array.from(state.filters.activeDays);
      if (!days.length) {
        panel.innerHTML = '<div class="empty-state"><strong>Select at least one day to view light forecast.</strong></div>';
        return;
      }

      const fragment = document.createDocumentFragment();
      days.forEach((day) => {
        computeLightForDay(day);
        const entry = state.dayMap[day];
        const wrapper = document.createElement('div');
        wrapper.className = 'light-block';
        wrapper.innerHTML = `
          <h2>${formatDayLabel(day)}</h2>
          <div class="light-grid">
            ${renderLightCard('Civil dawn', entry.light.dawn)}
            ${renderLightCard('Sunrise', entry.light.sunrise)}
            ${renderLightCard('Sunset', entry.light.sunset)}
            ${renderLightCard('Civil dusk', entry.light.dusk)}
            ${renderMoonCard(entry.moon)}
          </div>
        `;
        fragment.append(wrapper);
      });
      panel.append(fragment);
    }

    function renderLightCard(label, date) {
      return `
        <div class="light-card">
          <span>${label}</span>
          <strong>${date ? formatTime(date) : '—'}</strong>
        </div>
      `;
    }

    function renderMoonCard(moon) {
      return `
        <div class="light-card">
          <span>Moonrise</span>
          <strong>${moon.rise ? formatTime(moon.rise) : '—'}</strong>
          <span>Moonset</span>
          <strong>${moon.set ? formatTime(moon.set) : '—'}</strong>
          <span>Illumination</span>
          <strong>${moon.illumination ? Math.round(moon.illumination * 100) + '%' : '—'}</strong>
        </div>
      `;
    }

    function renderControlPanel() {
      const panel = elements.controlPanel;
      panel.innerHTML = '';

      const controls = [
        createDatePicker('Day A', 'dayA'),
        createDatePicker('Day B', 'dayB'),
        createRankSlider(),
        createSearchInput(),
      ];

      const filterRow = document.createElement('div');
      filterRow.className = 'controls-row';
      filterRow.append(createDayChips(), createBlockChips());

      controls.forEach((control) => panel.append(control));
      panel.append(filterRow, createUtilityButtons());
    }

    function createDatePicker(labelText, key) {
      const wrapper = document.createElement('label');
      wrapper.textContent = labelText;
      const input = document.createElement('input');
      input.type = 'date';
      input.value = state.filters[key] ?? '';
      input.addEventListener('change', () => {
        state.filters[key] = input.value;
        if (key === 'dayA' || key === 'dayB') {
          state.filters.activeDays = new Set([
            state.filters.dayA,
            state.filters.dayB,
          ].filter(Boolean));
          updateLightPanels();
        }
        persistState();
        applyFilters();
        renderLocations();
        updateMapMarkers();
      });
      wrapper.append(input);
      return wrapper;
    }

    function createRankSlider() {
      const wrapper = document.createElement('label');
      wrapper.textContent = `Rank #${state.filters.rankMin}–#${state.filters.rankMax}`;

      const container = document.createElement('div');
      container.className = 'dual-slider';

      const minInput = document.createElement('input');
      minInput.type = 'range';
      minInput.min = '1';
      minInput.max = '5';
      minInput.step = '1';
      minInput.value = String(state.filters.rankMin);

      const maxInput = document.createElement('input');
      maxInput.type = 'range';
      maxInput.min = '1';
      maxInput.max = '5';
      maxInput.step = '1';
      maxInput.value = String(state.filters.rankMax);

      const valueLabel = document.createElement('span');
      valueLabel.textContent = `Showing ranks #${state.filters.rankMin}–#${state.filters.rankMax}`;

      function updateRange() {
        let min = Number(minInput.value);
        let max = Number(maxInput.value);
        if (min > max) {
          [min, max] = [max, min];
        }
        state.filters.rankMin = min;
        state.filters.rankMax = max;
        wrapper.firstChild.textContent = `Rank #${min}–#${max}`;
        valueLabel.textContent = `Showing ranks #${min}–#${max}`;
        applyFilters();
        renderLocations();
        updateMapMarkers();
        persistState();
      }

      minInput.addEventListener('input', updateRange);
      maxInput.addEventListener('input', updateRange);

      container.append(minInput, maxInput, valueLabel);
      wrapper.append(container);
      return wrapper;
    }

    function createSearchInput() {
      const wrapper = document.createElement('label');
      wrapper.textContent = 'Search';
      const input = document.createElement('input');
      input.type = 'search';
      input.placeholder = 'Search locations, pins, shots...';
      input.value = state.filters.search;
      input.addEventListener('input', () => {
        state.filters.search = input.value;
        applyFilters();
        renderLocations();
        updateMapMarkers();
        persistState();
      });
      wrapper.append(input);
      return wrapper;
    }

    function createDayChips() {
      const container = document.createElement('div');
      container.className = 'chip-group';
      const uniqueDays = Array.from(new Set(state.locations.map((loc) => loc.day))).sort();
      uniqueDays.forEach((day) => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = `chip ${state.filters.activeDays.has(day) ? 'active' : ''}`;
        chip.textContent = formatDayLabel(day);
        chip.addEventListener('click', () => {
          if (state.filters.activeDays.has(day)) state.filters.activeDays.delete(day);
          else state.filters.activeDays.add(day);
          if (!state.filters.activeDays.size) {
            state.filters.activeDays.add(day);
          }
          updateLightPanels();
          applyFilters();
          renderLocations();
          updateMapMarkers();
          persistState();
          renderControlPanel();
        });
        container.append(chip);
      });
      return container;
    }

    function createBlockChips() {
      const container = document.createElement('div');
      container.className = 'chip-group';
      BLOCKS.forEach((block) => {
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = `chip ${state.filters.blocks.has(block) ? 'active' : ''}`;
        chip.textContent = block;
        chip.addEventListener('click', () => {
          if (state.filters.blocks.has(block)) state.filters.blocks.delete(block);
          else state.filters.blocks.add(block);
          if (!state.filters.blocks.size) {
            state.filters.blocks.add(block);
          }
          applyFilters();
          renderLocations();
          updateMapMarkers();
          persistState();
          renderControlPanel();
        });
        container.append(chip);
      });
      return container;
    }

    function createUtilityButtons() {
      const wrapper = document.createElement('div');
      wrapper.className = 'controls-row';

      const buttons = [
        { label: 'Expand all', action: expandAll },
        { label: 'Collapse all', action: collapseAll },
        { label: 'Export CSV', action: exportCsv },
        { label: 'Export KML', action: exportKml },
        { label: 'Export JSON', action: exportJson },
        { label: 'Import JSON', action: () => elements.importInput.click() },
        { label: 'Print', action: () => window.print() },
      ];

      buttons.forEach(({ label, action }) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.textContent = label;
        button.addEventListener('click', action);
        wrapper.append(button);
      });

      return wrapper;
    }

    function expandAll() {
      state.filtered.forEach((location) => state.expandedCards.add(location.id));
      persistState();
      renderLocations();
    }

    function collapseAll() {
      state.expandedCards.clear();
      persistState();
      renderLocations();
    }

    function exportCsv() {
      const rows = [
        ['Name', 'Day', 'Block', 'Rank', 'Why now', 'Gear', 'Settings'],
        ...state.filtered.map((loc) => [
          loc.name,
          loc.day,
          loc.block,
          loc.rank,
          loc.whyNow,
          loc.gear,
          loc.settings,
        ]),
      ];
      const csv = rows
        .map((row) => row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(','))
        .join('\n');
      downloadFile(`nyc-photo-guide-${Date.now()}.csv`, 'text/csv', csv);
      showToast('CSV exported.');
    }

    function exportKml() {
      const placemarks = state.filtered
        .map((loc) => {
          const anchor = loc.anchors[getActiveAnchorIndex(loc)];
          return `
            <Placemark>
              <name>${escapeXml(loc.name)}</name>
              <description>${escapeXml(loc.whyNow)}</description>
              <Point><coordinates>${anchor.lon},${anchor.lat},0</coordinates></Point>
            </Placemark>
          `;
        })
        .join('');
      const kml = `<?xml version="1.0" encoding="UTF-8"?>
        <kml xmlns="http://www.opengis.net/kml/2.2">
          <Document>
            <name>NYC Photo Guide</name>
            ${placemarks}
          </Document>
        </kml>`;
      downloadFile(`nyc-photo-guide-${Date.now()}.kml`, 'application/vnd.google-earth.kml+xml', kml);
      showToast('KML exported.');
    }

    function exportJson() {
      const payload = {
        LOCATIONS: state.locations,
        state: {
          filters: { ...state.filters, activeDays: Array.from(state.filters.activeDays), blocks: Array.from(state.filters.blocks) },
          anchorOverrides: state.anchorOverrides,
          dayMap: state.dayMap,
          expandedCards: Array.from(state.expandedCards),
          mapMode: state.mapMode,
        },
      };
      downloadFile(`nyc-photo-guide-${Date.now()}.json`, 'application/json', JSON.stringify(payload, null, 2));
      showToast('JSON exported.');
    }

    function downloadFile(filename, type, content) {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.click();
      URL.revokeObjectURL(url);
    }

    function escapeXml(input) {
      return input.replace(/[<>&"']/g, (char) => {
        switch (char) {
          case '<':
            return '<';
          case '>':
            return '>';
          case '&':
            return '&';
          case '"':
            return '"';
          case '\'':
            return ''';
          default:
            return char;
        }
      });
    }

    function setupImportHandler() {
      elements.importInput.addEventListener('change', async () => {
        const file = elements.importInput.files?.[0];
        if (!file) return;
        try {
          const text = await file.text();
          const payload = JSON.parse(text);
          if (!payload || !payload.LOCATIONS) throw new Error('Invalid schema');
          state.locations = payload.LOCATIONS;
          if (payload.state) {
            applyImportedState(payload.state);
          }
          persistState();
          ensureDefaultDates();
          updateLightPanels();
          applyFilters();
          renderControlPanel();
          renderLocations();
          updateMapMarkers();
          showToast('Plan imported successfully.', 'success');
        } catch (error) {
          console.error('Import failed', error);
          showToast('Import failed. Check file format.', 'error');
        } finally {
          elements.importInput.value = '';
        }
      });
    }

    function applyImportedState(importedState) {
      if (importedState.filters) {
        const { filters } = importedState;
        state.filters = {
          ...state.filters,
          ...filters,
          activeDays: new Set(filters.activeDays || []),
          blocks: new Set(filters.blocks || BLOCKS),
        };
      }
      if (importedState.anchorOverrides) state.anchorOverrides = importedState.anchorOverrides;
      if (importedState.dayMap) state.dayMap = importedState.dayMap;
      if (importedState.expandedCards) state.expandedCards = new Set(importedState.expandedCards);
      if (importedState.mapMode) state.mapMode = importedState.mapMode;
    }

    function applyPersistedState() {
      const raw = localStorage.getItem(LOCAL_STORAGE_KEY);
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        applyImportedState(data);
      } catch (error) {
        console.warn('Failed to parse persisted state', error);
      }
    }

    function persistState() {
      const payload = {
        filters: {
          ...state.filters,
          activeDays: Array.from(state.filters.activeDays),
          blocks: Array.from(state.filters.blocks),
        },
        anchorOverrides: state.anchorOverrides,
        dayMap: state.dayMap,
        expandedCards: Array.from(state.expandedCards),
        mapMode: state.mapMode,
      };
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(payload));
    }

    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = message;
      if (type === 'error') toast.style.borderColor = 'rgba(255, 107, 107, 0.6)';
      if (type === 'success') toast.style.borderColor = 'rgba(78, 205, 196, 0.6)';
      elements.toastContainer.append(toast);
      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateY(10px)';
        toast.addEventListener('transitionend', () => toast.remove(), { once: true });
      }, 3200);
    }

    async function ensureGoogleMap() {
      if (state.google.map) return;
      if (!state.google.scriptLoaded) {
        await loadGoogleMapsScript();
      }
      const anchor = document.getElementById('map-google');
      state.google.map = new google.maps.Map(anchor, {
        center: { lat: 40.7128, lng: -74.006 },
        zoom: 12,
        styles: googleDarkStyle,
        mapTypeControl: false,
        streetViewControl: false,
        fullscreenControl: false,
      });
      state.google.directionsService = new google.maps.DirectionsService();
      state.google.directionsRenderer = new google.maps.DirectionsRenderer({ suppressMarkers: true });
      state.google.directionsRenderer.setMap(state.google.map);
      state.google.distanceMatrix = new google.maps.DistanceMatrixService();
      state.google.placesService = new google.maps.places.PlacesService(state.google.map);
    }

    async function loadGoogleMapsScript() {
      if (document.getElementById('google-maps-script')) {
        await waitForGoogleMaps();
        return;
      }
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.id = 'google-maps-script';
        script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_KEY}&libraries=places`;
        script.async = true;
        script.onload = () => {
          state.google.scriptLoaded = true;
          resolve();
        };
        script.onerror = (error) => reject(error);
        document.head.append(script);
      });
      await waitForGoogleMaps();
    }

    function waitForGoogleMaps() {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const timer = setInterval(() => {
          if (window.google?.maps) {
            clearInterval(timer);
            resolve();
          } else if (attempts > 20) {
            clearInterval(timer);
            reject(new Error('Google Maps failed to load'));
          }
          attempts += 1;
        }, 150);
      });
    }

    async function ensureLeafletMap() {
      if (state.leaflet.map) return;
      await waitForLeaflet();
      state.leaflet.map = L.map(elements.mapLeaflet, {
        center: [40.7128, -74.006],
        zoom: 12,
        zoomControl: false,
      });
      L.control.zoom({ position: 'topright' }).addTo(state.leaflet.map);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors',
        maxZoom: 19,
      }).addTo(state.leaflet.map);

      state.leaflet.anchorLayer = L.layerGroup().addTo(state.leaflet.map);
      state.leaflet.microLayer = L.layerGroup().addTo(state.leaflet.map);
      state.leaflet.routeLayer = L.layerGroup().addTo(state.leaflet.map);
    }

    function waitForLeaflet() {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const timer = setInterval(() => {
          if (window.L) {
            clearInterval(timer);
            resolve();
          } else if (attempts > 20) {
            clearInterval(timer);
            reject(new Error('Leaflet failed to load'));
          }
          attempts += 1;
        }, 150);
      });
    }

    function renderMapTabs() {
      elements.mapTabs.innerHTML = '';
      const googleButton = document.createElement('button');
      googleButton.type = 'button';
      googleButton.textContent = 'Google Maps';
      googleButton.className = state.mapMode === 'google' ? 'active' : '';
      googleButton.addEventListener('click', async () => {
        state.mapMode = 'google';
        try {
          await ensureGoogleMap();
        } catch (error) {
          console.error('Google Maps failed to load', error);
          showToast('Google Maps failed. Falling back to Leaflet.', 'error');
          state.mapMode = 'leaflet';
        }
        updateMapVisibility();
        updateMapMarkers();
        persistState();
      });

      const leafletButton = document.createElement('button');
      leafletButton.type = 'button';
      leafletButton.textContent = 'Leaflet';
      leafletButton.className = state.mapMode === 'leaflet' ? 'active' : '';
      leafletButton.addEventListener('click', async () => {
        state.mapMode = 'leaflet';
        try {
          await ensureLeafletMap();
        } catch (error) {
          console.error('Leaflet init failed', error);
          showToast('Leaflet map failed. Trying Google Maps.', 'error');
          state.mapMode = 'google';
          await ensureGoogleMap().catch(() => showToast('Maps unavailable.', 'error'));
        }
        updateMapVisibility();
        updateMapMarkers();
        persistState();
      });

      elements.mapTabs.append(googleButton, leafletButton);
      elements.mapTabs.className = 'map-tabs';
      updateMapVisibility();
    }

    function updateMapVisibility() {
      if (state.mapMode === 'google') {
        elements.mapGoogle.hidden = false;
        elements.mapLeaflet.hidden = true;
        elements.mapTabs.querySelectorAll('button').forEach((btn) => btn.classList.toggle('active', btn.textContent === 'Google Maps'));
      } else {
        elements.mapGoogle.hidden = true;
        elements.mapLeaflet.hidden = false;
        elements.mapTabs.querySelectorAll('button').forEach((btn) => btn.classList.toggle('active', btn.textContent === 'Leaflet'));
      }
    }

    function updateMapMarkers() {
      if (state.mapMode === 'google') {
        renderGoogleMarkers();
      } else {
        renderLeafletMarkers();
      }
    }

    function renderGoogleMarkers() {
      if (!state.google.map) return;
      state.google.markers.forEach((marker) => marker.setMap(null));
      state.google.markers = [];

      const bounds = new google.maps.LatLngBounds();
      state.filtered.forEach((location) => {
        const anchorIndex = getActiveAnchorIndex(location);
        const anchor = location.anchors[anchorIndex];
        const anchorPosition = new google.maps.LatLng(anchor.lat, anchor.lon);
        const marker = new google.maps.Marker({
          position: anchorPosition,
          map: state.google.map,
          title: location.name,
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 8,
            fillColor: '#5b8def',
            fillOpacity: 1,
            strokeColor: '#ffffff',
            strokeWeight: 1,
          },
        });
        state.google.markers.push(marker);
        bounds.extend(anchorPosition);

        location.micro.forEach((micro) => {
          const coords = computeMicroPin(anchor, micro);
          const microMarker = new google.maps.Marker({
            position: { lat: coords.lat, lng: coords.lon },
            map: state.google.map,
            title: micro.title,
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              scale: 5,
              fillColor: '#4ecdc4',
              fillOpacity: 1,
              strokeColor: '#ffffff',
              strokeWeight: 1,
            },
          });
          state.google.markers.push(microMarker);
          bounds.extend(microMarker.getPosition());
        });
      });

      if (!bounds.isEmpty()) {
        state.google.map.fitBounds(bounds, { padding: 60 });
      }
    }

    function renderLeafletMarkers() {
      if (!state.leaflet.map) return;
      state.leaflet.anchorLayer.clearLayers();
      state.leaflet.microLayer.clearLayers();

      const markers = [];
      state.filtered.forEach((location) => {
        const anchorIndex = getActiveAnchorIndex(location);
        const anchor = location.anchors[anchorIndex];
        const anchorMarker = L.circleMarker([anchor.lat, anchor.lon], {
          radius: 7,
          color: '#ffffff',
          weight: 1,
          fillColor: '#5b8def',
          fillOpacity: 1,
        }).addTo(state.leaflet.anchorLayer);
        anchorMarker.bindPopup(`<strong>${location.name}</strong><br/>${location.block} — #${location.rank}`);
        markers.push(anchorMarker);

        location.micro.forEach((micro) => {
          const coords = computeMicroPin(anchor, micro);
          const microMarker = L.circleMarker([coords.lat, coords.lon], {
            radius: 5,
            color: '#ffffff',
            weight: 1,
            fillColor: '#4ecdc4',
            fillOpacity: 1,
          }).addTo(state.leaflet.microLayer);
          microMarker.bindPopup(`<strong>${micro.title}</strong><br/>${micro.detail}`);
          markers.push(microMarker);
        });
      });

      if (markers.length) {
        const group = L.featureGroup(markers);
        state.leaflet.map.fitBounds(group.getBounds(), { padding: [40, 40] });
      }
    }

    async function focusLocationOnMap(location) {
      if (state.mapMode === 'google') {
        await ensureGoogleMap();
        const anchorIndex = getActiveAnchorIndex(location);
        const anchor = location.anchors[anchorIndex];
        const bounds = new google.maps.LatLngBounds();
        bounds.extend(new google.maps.LatLng(anchor.lat, anchor.lon));
        location.micro.forEach((micro) => {
          const coords = computeMicroPin(anchor, micro);
          bounds.extend(new google.maps.LatLng(coords.lat, coords.lon));
        });
        state.google.map.fitBounds(bounds, { padding: 60 });
      } else {
        await ensureLeafletMap();
        const anchorIndex = getActiveAnchorIndex(location);
        const anchor = location.anchors[anchorIndex];
        const points = [[anchor.lat, anchor.lon]];
        location.micro.forEach((micro) => {
          const coords = computeMicroPin(anchor, micro);
          points.push([coords.lat, coords.lon]);
        });
        const bounds = L.latLngBounds(points);
        state.leaflet.map.fitBounds(bounds, { padding: [50, 50] });
      }
    }

    function openAnchorInMaps(location) {
      const anchor = location.anchors[getActiveAnchorIndex(location)];
      const url = `https://www.google.com/maps/search/?api=1&query=${anchor.lat},${anchor.lon}`;
      window.open(url, '_blank');
    }

    function openAnchorDirections(location) {
      const anchor = location.anchors[getActiveAnchorIndex(location)];
      const url = `https://www.google.com/maps/dir/?api=1&destination=${anchor.lat},${anchor.lon}&travelmode=walking`;
      window.open(url, '_blank');
    }

    async function requestEta(location) {
      if (state.mapMode !== 'google') {
        showToast('Switch to Google Maps for ETA.', 'error');
        return;
      }
      await ensureGoogleMap();
      const position = await getCurrentPosition();
      if (!position) return;

      const anchor = location.anchors[getActiveAnchorIndex(location)];
      state.google.distanceMatrix.getDistanceMatrix(
        {
          origins: [new google.maps.LatLng(position.coords.latitude, position.coords.longitude)],
          destinations: [new google.maps.LatLng(anchor.lat, anchor.lon)],
          travelMode: google.maps.TravelMode.WALKING,
        },
        (response, status) => {
          if (status !== 'OK') {
            showToast('ETA unavailable.', 'error');
            return;
          }
          const result = response.rows?.[0]?.elements?.[0];
          if (result?.status !== 'OK') {
            showToast('ETA unavailable.', 'error');
            return;
          }
          showToast(`ETA: ${result.duration.text} (${result.distance.text})`, 'success');
        }
      );
    }

    async function requestRoute(location) {
      if (state.mapMode !== 'google') {
        showToast('Switch to Google Maps for routing.', 'error');
        return;
      }
      await ensureGoogleMap();
      const position = await getCurrentPosition();
      if (!position) return;

      const anchor = location.anchors[getActiveAnchorIndex(location)];
      const origin = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
      const destination = new google.maps.LatLng(anchor.lat, anchor.lon);
      state.google.directionsService.route(
        {
          origin,
          destination,
          travelMode: google.maps.TravelMode.WALKING,
        },
        (result, status) => {
          if (status === 'OK') {
            state.google.directionsRenderer.setDirections(result);
            showToast('Walking route displayed.', 'success');
          } else {
            showToast('Directions unavailable.', 'error');
          }
        }
      );
    }

    function getCurrentPosition() {
      return new Promise((resolve) => {
        if (!navigator.geolocation) {
          showToast('Geolocation not supported.', 'error');
          resolve(null);
          return;
        }
        navigator.geolocation.getCurrentPosition(resolve, (error) => {
          console.warn('Geolocation error', error);
          showToast('Location permission denied.', 'error');
          resolve(null);
        });
      });
    }

    async function loadReferenceImages(button, location) {
      if (state.mapMode !== 'google') {
        showToast('Reference images require Google Maps mode.', 'error');
        return;
      }
      await ensureGoogleMap();
      const container = button.nextElementSibling;
      if (!container || !(container instanceof HTMLElement)) return;
      const cacheKey = location.id;
      if (state.referenceCache[cacheKey]) {
        renderReferenceImages(container, state.referenceCache[cacheKey]);
        button.hidden = true;
        container.hidden = false;
        return;
      }
      button.disabled = true;
      button.textContent = 'Loading photos...';
      try {
        const request = {
          query: location.placeQuery || location.name,
          locationBias: new google.maps.LatLngBounds(
            new google.maps.LatLng(40.55, -74.2),
            new google.maps.LatLng(40.9, -73.7)
          ),
        };
        state.google.placesService.textSearch(request, (results, status) => {
          if (status !== google.maps.places.PlacesServiceStatus.OK || !results?.length) {
            button.textContent = 'No images found';
            return;
          }
          const photos = results[0].photos?.slice(0, 12) || [];
          if (!photos.length) {
            button.textContent = 'No images found';
            return;
          }
          const urls = photos.map((photo) => photo.getUrl({ maxWidth: 800, maxHeight: 800 }));
          state.referenceCache[cacheKey] = urls;
          renderReferenceImages(container, urls);
          button.hidden = true;
          container.hidden = false;
        });
      } catch (error) {
        console.error('Places photos error', error);
        button.textContent = 'Failed to load photos';
      }
    }

    function renderReferenceImages(container, urls) {
      container.innerHTML = urls
        .map((url) => `<img src="${url}" alt="Reference scene" loading="lazy" />`)
        .join('');
    }

    function renderLeafletRoute(points) {
      state.leaflet.routeLayer.clearLayers();
      const polyline = L.polyline(points, { color: '#5b8def', weight: 4, opacity: 0.8 }).addTo(state.leaflet.routeLayer);
      state.leaflet.map.fitBounds(polyline.getBounds(), { padding: [40, 40] });
    }

    const googleDarkStyle = [
      { elementType: 'geometry', stylers: [{ color: '#1d2c4d' }] },
      { elementType: 'labels.text.fill', stylers: [{ color: '#8ec3b9' }] },
      { elementType: 'labels.text.stroke', stylers: [{ color: '#1a3646' }] },
      { featureType: 'administrative.country', elementType: 'geometry.stroke', stylers: [{ color: '#4b6878' }] },
      { featureType: 'administrative.land_parcel', elementType: 'labels.text.fill', stylers: [{ color: '#64779e' }] },
      { featureType: 'administrative.province', elementType: 'geometry.stroke', stylers: [{ color: '#4b6878' }] },
      { featureType: 'landscape.man_made', elementType: 'geometry.stroke', stylers: [{ color: '#334e87' }] },
      { featureType: 'landscape.natural', elementType: 'geometry', stylers: [{ color: '#023e58' }] },
      { featureType: 'landscape.natural.landcover', elementType: 'geometry', stylers: [{ color: '#0e4457' }] },
      { featureType: 'landscape.natural.terrain', elementType: 'geometry', stylers: [{ color: '#1a3646' }] },
      { featureType: 'poi', elementType: 'geometry', stylers: [{ color: '#283d6a' }] },
      { featureType: 'poi', elementType: 'labels.text.fill', stylers: [{ color: '#6f9ba5' }] },
      { featureType: 'poi', elementType: 'labels.text.stroke', stylers: [{ color: '#1d2c4d' }] },
      { featureType: 'poi.park', elementType: 'geometry.fill', stylers: [{ color: '#023e58' }] },
      { featureType: 'poi.park', elementType: 'labels.text.fill', stylers: [{ color: '#3C7680' }] },
      { featureType: 'road', elementType: 'geometry', stylers: [{ color: '#304a7d' }] },
      { featureType: 'road', elementType: 'geometry.stroke', stylers: [{ color: '#1c2c4b' }] },
      { featureType: 'road', elementType: 'labels.text.fill', stylers: [{ color: '#98a5be' }] },
      { featureType: 'road', elementType: 'labels.text.stroke', stylers: [{ color: '#1a3646' }] },
      { featureType: 'road.highway', elementType: 'geometry', stylers: [{ color: '#2c6675' }] },
      { featureType: 'road.highway', elementType: 'geometry.stroke', stylers: [{ color: '#255763' }] },
      { featureType: 'road.highway', elementType: 'labels.text.fill', stylers: [{ color: '#b0d5ce' }] },
      { featureType: 'road.highway', elementType: 'labels.text.stroke', stylers: [{ color: '#023e58' }] },
      { featureType: 'transit', elementType: 'labels.text.fill', stylers: [{ color: '#98a5be' }] },
      { featureType: 'transit', elementType: 'labels.text.stroke', stylers: [{ color: '#1d2c4d' }] },
      { featureType: 'transit.line', elementType: 'geometry.fill', stylers: [{ color: '#283d6a' }] },
      { featureType: 'transit.station', elementType: 'geometry', stylers: [{ color: '#3a4762' }] },
      { featureType: 'water', elementType: 'geometry', stylers: [{ color: '#0e1626' }] },
      { featureType: 'water', elementType: 'labels.text.fill', stylers: [{ color: '#4e6d70' }] },
    ];
  </script>
</body>
</html>
