<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NYC Photo Guide — v7.1 Hybrid</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
:root{
  --bg:#0b1220; --panel:#0f172a; --card:#0e1426; --text:#e6edf6; --muted:#9bb0c9;
  --border:#1f2a44; --shadow: rgba(0,0,0,.35);
  --blue:#60a5fa; --amber:#fbbf24; --violet:#a78bfa; --rose:#fb7185; --teal:#2dd4bf; --green:#34d399;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;background:var(--bg);color:var(--text)}
header{position:sticky;top:0;z-index:40;background:linear-gradient(90deg,#0b1220,#10203c);
  border-bottom:1px solid var(--border);box-shadow:0 6px 20px var(--shadow)}
.header-inner{max-width:1280px;margin:0 auto;display:flex;flex-wrap:wrap;gap:.6rem;align-items:center;padding:.7rem .9rem}
h1{font-size:1.06rem;margin:0 1rem 0 0;font-weight:800;letter-spacing:.02em}
.controls{display:flex;flex-wrap:wrap;gap:.45rem;align-items:center}
.controls input[type="date"], .controls input[type="search"], .controls select{
  background:#0b1326;color:var(--text);border:1px solid var(--border);padding:.45rem .6rem;border-radius:.5rem}
.controls button,.chip,label.chip{background:#0a1326;color:var(--text);border:1px solid var(--border);
  padding:.45rem .6rem;border-radius:.55rem;cursor:pointer;box-shadow:0 1px 3px var(--shadow)}
.controls button:hover{border-color:#314165}
main{max-width:1280px;margin:0 auto;display:grid;grid-template-columns:minmax(360px,560px) 1fr;gap:1rem;padding:1rem}
@media(max-width:980px){main{grid-template-columns:1fr} .mapWrap{position:static} #leaflet,#gmap{height:360px}}
.sidebar{display:grid;gap:1rem}
.panel{background:var(--panel);border:1px solid var(--border);border-radius:1rem;padding:1rem;box-shadow:0 10px 30px var(--shadow)}
.section-title{margin:.2rem 0 .6rem 0;font-size:.92rem;color:var(--muted);font-weight:800;text-transform:uppercase;letter-spacing:.08em}
.grid{display:grid;gap:.8rem}
.card{background:var(--card);border:1px solid var(--border);border-radius:1rem;padding:.9rem;display:grid;gap:.5rem;box-shadow:0 8px 20px var(--shadow);position:relative;overflow:hidden}
.card:before{content:"";position:absolute;inset:0 0 auto 0;height:4px;background:linear-gradient(90deg,var(--blue),var(--violet));opacity:.9}
.card-header{display:flex;justify-content:space-between;gap:.75rem;align-items:baseline}
.card h3{margin:.1rem 0;font-size:1.02rem}
.badges{display:flex;gap:.4rem;align-items:center;flex-wrap:wrap}
.badge{font-size:.75rem;padding:.2rem .45rem;border-radius:.4rem;border:1px solid var(--border);background:#0b1326;color:#9fb3c8}
.badge.block-Morning{background:#0b203a;color:#a5e3ff;border-color:#133b67}
.badge.block-Afternoon{background:#2a1a00;color:#ffd08a;border-color:#704d12}
.badge.block-Evening{background:#1a1025;color:#e5d5ff;border-color:#4b3b63}
.badge.block-Night{background:#1e0c12;color:#ffc1c9;border-color:#5c1c2c}
.summary-line{color:var(--muted);font-size:.9rem}
.kv{display:grid;grid-template-columns:140px 1fr;gap:.35rem .6rem}
.kv .k{color:var(--muted);font-weight:600}
.actions{display:flex;gap:.4rem;flex-wrap:wrap}
.actions a,.actions button{background:#0b1326;color:var(--text);border:1px solid var(--border);padding:.38rem .6rem;border-radius:.5rem;text-decoration:none;font-size:.86rem}
.expand-list{list-style:none;padding-left:0;margin:.2rem 0}
.expand-item{margin:.3rem 0;border:1px dashed #273853;border-radius:.6rem;background:#0a1428}
.expand-summary{display:flex;justify-content:space-between;align-items:center;width:100%;padding:.5rem .6rem;background:transparent;border:none;color:#cfe1ff;font-weight:700;cursor:pointer;text-align:left}
.expand-summary .hint{color:#94a7c7;font-weight:500}
.expand-body{display:none;padding:.5rem .8rem .7rem .8rem;color:#cdd9e8;border-top:1px dashed #273853}
.expand-item.open .expand-body{display:block}
.pillset{display:flex;gap:.4rem;flex-wrap:wrap}
.pill{display:inline-flex;align-items:center;gap:.35rem;padding:.25rem .5rem;border-radius:999px;border:1px solid var(--border);background:#0b1326;color:#cfe1ff;font-size:.78rem}
.edit-banner{position:sticky;top:98px;z-index:19;background:#10203c;border:1px dashed #3b4f77;color:#e6edf6;padding:.5rem .75rem;border-radius:.6rem}
.mapWrap{position:sticky;top:130px;height:calc(100vh - 160px)}
#leaflet,#gmap{height:100%;border:1px solid var(--border);border-radius:1rem}
.modeTabs{display:flex;gap:.4rem;margin-bottom:.6rem;flex-wrap:wrap}
.modeTabs button{background:#0b1326;border:1px solid var(--border);color:#cfe1ff;border-radius:.5rem;padding:.35rem .55rem}
.modeTabs button.active{border-color:#60a5fa;box-shadow:0 0 0 2px rgba(96,165,250,.25) inset}
.ref-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:.5rem}
.ref-grid img{width:100%;height:100px;object-fit:cover;border-radius:.4rem;border:1px solid #24324d}
.small{font-size:.84rem;color:#9fb3c8}
.hr{height:1px;background:linear-gradient(90deg,transparent,#2a3957,transparent);margin:.6rem 0}
</style>
</head>
<body>
<header>
  <div class="header-inner">
    <h1>NYC Photo Guide — v7.1 (Hybrid)</h1>
    <div class="controls">
      <span class="chip">Visit days (NYC time):</span>
      <input id="dateA" type="date" value="2025-10-03"/>
      <input id="dateB" type="date" value="2025-10-04"/>
      <span class="chip">Show days:</span>
      <label class="chip"><input type="checkbox" name="day" value="2025-10-03" checked/> Fri 10/03</label>
      <label class="chip"><input type="checkbox" name="day" value="2025-10-04" checked/> Sat 10/04</label>
      <span class="chip">Blocks:</span>
      <label class="chip"><input type="checkbox" name="block" value="Morning" checked/> Morning</label>
      <label class="chip"><input type="checkbox" name="block" value="Afternoon" checked/> Afternoon</label>
      <label class="chip"><input type="checkbox" name="block" value="Evening" checked/> Evening</label>
      <label class="chip"><input type="checkbox" name="block" value="Night" checked/> Night</label>
      <span class="chip">Rank <span id="rankLabel">#1–#5</span></span>
      <input id="rankMin" type="range" min="1" max="5" value="1"/>
      <input id="rankMax" type="range" min="1" max="5" value="5"/>
      <label class="chip"><input type="checkbox" id="proOnly"/> Pro only (#1–#2)</label>
      <label class="chip"><input type="checkbox" id="rain"/> Rain plan</label>
      <label class="chip"><input type="checkbox" id="wind"/> Wind‑safe</label>
      <input id="q" type="search" placeholder="Search…"/>
      <button id="expandAll">Expand all</button>
      <button id="collapseAll">Collapse all</button>
      <button id="exportCSV">Export CSV</button>
      <button id="exportKML">Export KML</button>
      <button id="print">Print</button>
      <button id="theme">Theme</button>
      <button id="exportJSON">Export JSON</button>
      <label class="chip">Import <input type="file" id="importJSON" accept="application/json"/></label>
    </div>
  </div>
</header>

<main>
  <div class="sidebar">
    <div class="panel">
      <div class="modeTabs">
        <button id="modeGoogle" title="Use Google Maps with Places, Street View, ETA, directions">Google Maps (online)</button>
        <button id="modeLeaflet" title="Use Leaflet/OSM offline fallback">Leaflet (offline)</button>
      </div>
      <div id="lightpanels" class="grid"></div>
    </div>

    <section class="panel">
      <div class="section-title">Rules & Reminders</div>
      <ul>
        <li>Observation decks often restrict <b>tripods</b>. Shoot handheld or with a mini support.</li>
        <li>Grand Central / NYPL / Oculus interior: casual photos are fine; professional rigs/tripods usually <b>require permits</b>.</li>
        <li>Subways: photography permitted without lights/reflectors/tripods. Stay behind safety lines.</li>
        <li>Waterfront long exposures: check <b>NOAA “The Battery” tides</b> (inline below) and wind.</li>
      </ul>
    </section>
    <div id="list" class="grid"></div>
  </div>

  <div class="mapWrap">
    <div id="gmap" class="panel" style="display:none;position:relative">
      <div id="gsv" style="position:absolute;right:8px;bottom:8px;width:30%;height:30%;border:1px solid var(--border);border-radius:.5rem;display:none"></div>
    </div>
    <div id="leaflet" class="panel" style="display:none"></div>
  </div>
</main>

<footer class="panel" style="max-width:1280px;margin:1rem auto">
  v7.1 Hybrid — Google Maps + Places (photos, reverse geocode, directions, Street View) with Leaflet fallback and live NOAA tides.
</footer>

<script>

(function(){
  const PI = Math.PI, rad = PI/180;
  const sin = Math.sin, cos = Math.cos, asin = Math.asin, acos = Math.acos, atan2 = Math.atan2;
  function toJulian(date){ return date/86400000 - 0.5 + 2440588; }
  function fromJulian(j){ return new Date((j + 0.5 - 2440588)*86400000); }
  function toDays(date){ return toJulian(date) - 2451545; }
  const e = rad*23.4397;
  function rightAscension(l,b){ return atan2(Math.sin(l)*Math.cos(e) - Math.tan(b)*Math.sin(e), Math.cos(l)); }
  function declination(l,b){ return asin(Math.sin(b)*Math.cos(e) + Math.cos(b)*Math.sin(e)*Math.sin(l)); }
  function siderealTime(d, lw){ return rad*(280.16 + 360.9856235*d) - lw; }
  function solarMeanAnomaly(d){ return rad*(357.5291 + 0.98560028*d); }
  function eclipticLongitude(M){ const C = rad*(1.9148*Math.sin(M) + 0.02*Math.sin(2*M) + 0.0003*Math.sin(3*M)); const P = rad*102.9372; return M + C + P + PI; }
  function sunCoords(d){ const M = solarMeanAnomaly(d), L = eclipticLongitude(M); return { dec: declination(L,0), ra: rightAscension(L,0) }; }
  function julianCycle(d, lw){ return Math.round(d - 0.0009 - lw/(2*PI)); }
  function approxTransit(Ht, lw, n){ return 0.0009 + (Ht + lw)/(2*PI) + n; }
  function solarTransitJ(ds, M, L){ return 2451545 + ds + 0.0053*Math.sin(M) - 0.0069*Math.sin(2*L); }
  function hourAngle(h, phi, d){ return acos((Math.sin(h) - Math.sin(phi)*Math.sin(d)) / (Math.cos(phi)*Math.cos(d))); }
  function getSetJ(h, lw, phi, dec, n, M, L){ const w = hourAngle(h, phi, dec), a = approxTransit(w, lw, n); return solarTransitJ(a, M, L); }

  window.SunCalc = {
    getSunTimes: function(date, lat, lng){
      const lw = rad*-lng, phi = rad*lat, d = toDays(date);
      const n = julianCycle(d, lw);
      const ds = approxTransit(0, lw, n);
      const M = solarMeanAnomaly(d);
      const L = eclipticLongitude(M);
      const dec = declination(L, 0);
      const Jnoon = solarTransitJ(ds, M, L);

      const h0 = (-0.833)*rad;
      const Jset = getSetJ(h0, lw, phi, dec, n, M, L);
      const Jrise = Jnoon - (Jset - Jnoon);
      const hCivil = (-6)*rad;
      const Jcset = getSetJ(hCivil, lw, phi, dec, n, M, L);
      const Jcrise= Jnoon - (Jcset - Jnoon);

      return {
        sunrise: fromJulian(Jrise),
        sunset: fromJulian(Jset),
        dawn: fromJulian(Jcrise),
        dusk: fromJulian(Jcset)
      };
    },
    getMoonTimes: function(date, lat, lng){
      function moonCoords(d){
        const rad = Math.PI/180;
        const L = rad*(218.316 + 13.176396*d),
              M = rad*(134.963 + 13.064993*d),
              F = rad*(93.272 + 13.229350*d);
        let l = L + rad*6.289*Math.sin(M);
        let b = rad*5.128*Math.sin(F);
        let dt= 385001 - 20905*Math.cos(M);
        const e = (23.4397*rad);
        function RA(l,b){ return Math.atan2(Math.sin(l)*Math.cos(e) - Math.tan(b)*Math.sin(e), Math.cos(l)); }
        function DEC(l,b){ return Math.asin(Math.sin(b)*Math.cos(e) + Math.cos(b)*Math.sin(e)*Math.sin(l)); }
        return { ra: RA(l,b), dec: DEC(l,b), dist: dt };
      }
      function toJulian(date){ return date/86400000 - 0.5 + 2440588; }
      function fromJulian(j){ return new Date((j + 0.5 - 2440588)*86400000); }
      function toDays(date){ return toJulian(date) - 2451545; }
      const lw = -lng*Math.PI/180, phi = lat*Math.PI/180;
      const d = toDays(new Date(date.setHours(0,0,0,0))) - 0.5 - lng/360;
      function altitude(d){
        const m = moonCoords(d), H = siderealTime(d, lw) - m.ra;
        return Math.asin(Math.sin(phi)*Math.sin(m.dec) + Math.cos(phi)*Math.cos(m.dec)*Math.cos(H)) - 0.017;
      }
      const h1 = altitude(d-1), h2 = altitude(d), h3 = altitude(d+1);
      const a = (h1 + h3)/2 - h2, b = (h3 - h1)/2, hc = 0.133*Math.PI/180;
      const dxe = Math.sqrt(Math.max(0, b*b - 4*a*(h2-hc)));
      let rise=null,set=null;
      if(dxe!==0){
        const x1 = (-b - dxe)/(2*a), x2 = (-b + dxe)/(2*a);
        if (x1>-1 && x1<1) rise = fromJulian(2451545 + d + x1);
        if (x2>-1 && x2<1) set  = fromJulian(2451545 + d + x2);
      }
      const sun = (function(d){ const M = (357.5291 + 0.98560028*d)*Math.PI/180; const C = (1.9148*Math.sin(M)+0.02*Math.sin(2*M)+0.0003*Math.sin(3*M))*Math.PI/180; const P=102.9372*Math.PI/180; const L=M+C+P+Math.PI; const dec=Math.asin(Math.sin(0)*Math.cos(23.4397*Math.PI/180)+Math.cos(0)*Math.sin(23.4397*Math.PI/180)*Math.sin(L)); const ra=Math.atan2(Math.sin(L)*Math.cos(23.4397*Math.PI/180)-Math.tan(0)*Math.sin(23.4397*Math.PI/180), Math.cos(L)); return {dec,ra}; })(d);
      const m = moonCoords(d); const sdist=149598000; const phiA = Math.acos(Math.sin(sun.dec)*Math.sin(m.dec) + Math.cos(sun.dec)*Math.cos(m.dec)*Math.cos(sun.ra-m.ra)); const inc=Math.atan2(sdist*Math.sin(phiA), m.dist - sdist*Math.cos(phiA)); const illumination=(1+Math.cos(inc))/2;
      return {rise,set,illum:illumination};
    }
  };
})();

</script>
<script>

const CFG = { apiKey: "AIzaSyDsq2ztFeFfmgqiRIZZtK5R7aCVGF66-80", nyc:{lat:40.7128,lon:-74.0060}, dataVersion:"v7.1" };
let LOCATIONS = [{"id": "bk_dumbo_keyhole", "name": "DUMBO \u2014 Washington & Water (Manhattan Bridge Keyhole)", "day": "2025-10-03", "block": "Morning", "rank": 1, "bearing": "NNE toward Manhattan", "whyNow": "Side-lit steel and cobbles; fewer crowds early.", "gear": "16\u201324\u202fmm for wide frame; 35\u202fmm for tighter car\u2011free moments.", "notes": "Arrive before delivery trucks; street cleaning can create wet reflections.", "rainFriendly": true, "windSafe": true, "settings": "Handheld: 1/250s+ @ f/5.6\u20138 ISO 100\u2013400; long exposure only before traffic starts.", "activeAnchor": 0, "anchors": [{"label": "Main view", "lat": 40.703307, "lon": -73.990039}, {"label": "Alternate mid\u2011block", "lat": 40.703519, "lon": -73.989764}], "micro": [{"title": "Centerline", "r": 0.0, "bearing": 0.0, "dir": "NNE", "detail": "Feet on the cobbles at the crown of Washington St; watch parked cars."}, {"title": "Crosswalk step\u2011back", "r": 10.0, "bearing": 200.0, "dir": "NNE", "detail": "Step back to clear parked vans; compress the arch a touch."}, {"title": "Corner curb", "r": 22.0, "bearing": 225.0, "dir": "NNE", "detail": "Use the curb for a low angle with cobble lead\u2011in."}], "pins": [{"title": "Parking gap watch", "detail": "Scan for a temporary car gap on the west side; shoot fast."}, {"title": "Reflections after wash", "detail": "City wash leaves sheen on cobbles\u2014polarizer helps manage glare."}, {"title": "Taxi streaks", "detail": "If traffic starts, drag the shutter 1/8\u20131/2s for motion streaks."}], "shots": [{"title": "Keyhole classic (16\u201324\u202fmm)", "detail": "Frame the ESB in the bridge opening; keep verticals straight."}, {"title": "Mid\u2011block symmetry (24\u201335\u202fmm)", "detail": "Full arch dominance; align the center seam with the roadway stripe."}, {"title": "Low\u2011angle cobbles (16\u201320\u202fmm)", "detail": "Camera just above ground for texture; mind passerby feet."}, {"title": "Backlit silhouettes (sunrise)", "detail": "Silhouette walkers crossing the street; expose for sky."}, {"title": "Tight ESB crop (35\u201350\u202fmm)", "detail": "Pull a graphic ESB framed by steel; wait for clean sidewalk."}]}];

// State
let state = {
  dayMap: {"2025-10-03":"2025-10-03","2025-10-04":"2025-10-04"},
  day: new Set(["2025-10-03","2025-10-04"]),
  blocks: new Set(["Morning","Afternoon","Evening","Night"]),
  rankMin:1, rankMax:5, proOnly:false, q:"", rain:false, wind:false, expandAll:false,
  mapMode:"auto", editMode:false, editWhat:"anchor"
};
let TIMES = {};

// Utils
function toFixed6(n){ return +n.toFixed(6); }
function metersToLatLon(lat, meters, heading){ const dlat=(meters*Math.cos(heading*Math.PI/180))/111111.0; const dlon=(meters*Math.sin(heading*Math.PI/180))/(111111.0*Math.cos(lat*Math.PI/180)); return {dlat,dlon}; }
function activeAnchor(loc){ return loc.anchors[loc.activeAnchor||0]; }
function computeMicroAbs(loc){ const a=activeAnchor(loc); return (loc.micro||[]).map(m=>{ const off=metersToLatLon(a.lat,m.r,m.bearing); return {title:m.title,lat:toFixed6(a.lat+off.dlat),lon:toFixed6(a.lon+off.dlon),dir:m.dir,r:m.r,bearing:m.bearing,detail:m.detail}; }); }
function dayLabelISO(iso){ const d=new Date(iso+"T12:00:00-04:00"); return new Intl.DateTimeFormat('en-US',{weekday:'short',month:'short',day:'numeric',year:'numeric'}).format(d).replace(',',' •'); }
function gmapsOpen(lat,lon){ return `https://www.google.com/maps/search/?api=1&query=${lat},${lon}`; }
function fmtHM(d){ const dt=new Date(d); let h=dt.getHours(), m=dt.getMinutes(); const ampm=h>=12?'pm':'am'; const h12=((h+11)%12)+1; return `${h12}:${String(m).padStart(2,'0')} ${ampm}`; }

// Light & Moon
function computeTimes(){
  TIMES={};
  ["2025-10-03","2025-10-04"].forEach(k=>{
    const iso=state.dayMap[k], dt=new Date(iso+'T12:00:00-04:00');
    const sun=SunCalc.getSunTimes(new Date(dt), CFG.nyc.lat, CFG.nyc.lon);
    const moon=SunCalc.getMoonTimes(new Date(dt), CFG.nyc.lat, CFG.nyc.lon);
    TIMES[k]={ sunrise:fmtHM(sun.sunrise), sunset:fmtHM(sun.sunset), civil_dawn:fmtHM(sun.dawn), civil_dusk:fmtHM(sun.dusk),
               moonrise: moon.rise?fmtHM(moon.rise):'—', moonset: moon.set?fmtHM(moon.set):'—', moonText: Math.round(moon.illum*100)+'% illum', iso };
  });
}

// NOAA
async function fetchNOAATides(iso){
  const ymd=iso.replace(/-/g,'');
  const url=`https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?product=predictions&application=nyc-photo-guide&begin_date=${ymd}&end_date=${ymd}&datum=MLLW&station=8518750&time_zone=lst_ldt&interval=hilo&units=english&format=json`;
  try{
    const r=await fetch(url, {cache:'no-store'}); const j=await r.json();
    if(j && j.predictions){ return j.predictions.map(p=>`${p.t.slice(11,16)} ${p.type} ${parseFloat(p.v).toFixed(1)} ft`).join(' • '); }
    return 'Open NOAA high/low';
  }catch{ return 'Open NOAA high/low'; }
}

// Maps (Google + Leaflet)
let usingGoogle=false, gmap=null, gDirections=null, gDirRenderer=null, gPlaces=null, gGeocoder=null, gsv=null;
let lmap=null, lLayer=null;
let mainMarkers={}, microMarkers={}, arrowPolylines={};

function injectGoogle(){
  return new Promise((resolve,reject)=>{
    if(window.google&&window.google.maps){ resolve(); return; }
    const s=document.createElement('script'); s.src=`https://maps.googleapis.com/maps/api/js?key=${CFG.apiKey}&libraries=places`; s.async=true; s.defer=true;
    s.onload=resolve; s.onerror=()=>reject(new Error('Google Maps failed to load')); document.head.appendChild(s);
  });
}
function initGoogle(){
  usingGoogle=true;
  document.getElementById('leaflet').style.display='none';
  const el=document.getElementById('gmap'); el.style.display='block';
  gmap=new google.maps.Map(el,{center:{lat:40.73,lng:-73.98},zoom:12,mapTypeControl:true,streetViewControl:true});
  gsv=new google.maps.StreetViewPanorama(document.getElementById('gsv'),{visible:false});
  gmap.setStreetView(gsv);
  gDirections=new google.maps.DirectionsService();
  gDirRenderer=new google.maps.DirectionsRenderer({suppressMarkers:true,preserveViewport:true}); gDirRenderer.setMap(gmap);
  gPlaces=new google.maps.places.PlacesService(gmap);
  gGeocoder=new google.maps.Geocoder();
}
function initLeaflet(){
  usingGoogle=false;
  document.getElementById('gmap').style.display='none';
  const el=document.getElementById('leaflet'); el.style.display='block';
  if(!lmap){
    lmap=L.map('leaflet').setView([40.73,-73.98],12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'&copy; OpenStreetMap'}).addTo(lmap);
    lLayer=L.layerGroup().addTo(lmap);
  }
}

function clearMap(){
  if(usingGoogle){
    if(!gmap) return;
    Object.values(mainMarkers).forEach(m=>m.setMap(null)); mainMarkers={};
    Object.values(microMarkers).forEach(arr=>arr.forEach(m=>m.setMap(null))); microMarkers={};
    Object.values(arrowPolylines).forEach(arr=>arr.forEach(p=>p.setMap(null))); arrowPolylines={};
  } else {
    if(!lLayer) return;
    lLayer.clearLayers();
    mainMarkers={}; microMarkers={}; arrowPolylines={};
  }
}
function blockColor(b){ return (b==='Morning')?'#60a5fa':(b==='Afternoon')?'#fbbf24':(b==='Evening')?'#a78bfa':'#fb7185'; }
function visibleLocations(){
  return (LOCATIONS||[]).filter(loc=> state.day.has(loc.day) && state.blocks.has(loc.block) && loc.rank>=state.rankMin && loc.rank<=state.rankMax );
}
function renderMarkers(){
  // Guard until a map engine is ready
  if(usingGoogle && !gmap) return;
  if(!usingGoogle && !lmap) return;
  clearMap();
  const vis=visibleLocations();
  if(usingGoogle){
    const bounds=new google.maps.LatLngBounds();
    vis.forEach(loc=>{
      const a=activeAnchor(loc);
      const mm=new google.maps.Marker({position:{lat:a.lat,lng:a.lon}, map:gmap, title:loc.name,
        icon:{path:google.maps.SymbolPath.CIRCLE, scale:6, fillColor:blockColor(loc.block), fillOpacity:1, strokeColor:'#0b1220', strokeWeight:2}});
      mainMarkers[loc.id]=mm; bounds.extend(mm.getPosition());
      const micro=computeMicroAbs(loc);
      microMarkers[loc.id]=micro.map(mp=>{
        const m=new google.maps.Marker({position:{lat:mp.lat,lng:mp.lon}, map:gmap, title:mp.title,
          icon:{path:google.maps.SymbolPath.CIRCLE, scale:4, fillColor:'#2dd4bf', fillOpacity:1, strokeColor:'#093b36', strokeWeight:1}});
        return m;
      });
    });
    if(!bounds.isEmpty()) gmap.fitBounds(bounds, 80);
  } else {
    const pts=[];
    vis.forEach(loc=>{
      const a=activeAnchor(loc);
      L.circleMarker([a.lat,a.lon],{radius:8,weight:2,color:blockColor(loc.block),fillOpacity:.95,fillColor:blockColor(loc.block)}).addTo(lLayer);
      pts.push([a.lat,a.lon]);
      computeMicroAbs(loc).forEach(mp=> L.circleMarker([mp.lat,mp.lon],{radius:4,weight:1,color:'#2dd4bf',fillColor:'#2dd4bf',fillOpacity:.95}).addTo(lLayer) );
    });
    if(pts.length) lmap.fitBounds(pts, {padding:[80,80]});
  }
}

// Reference Images via Places
function loadReferencePhotos(container, loc){
  if(!usingGoogle || !gPlaces){ container.textContent='Switch to Google mode to load images.'; return; }
  const a=activeAnchor(loc); const query=loc.placeQuery||loc.name;
  gPlaces.findPlaceFromQuery({ query, fields:['place_id','name','geometry'], locationBias:{radius:300, center:{lat:a.lat,lng:a.lon}} }, (res,status)=>{
    if(status!=='OK' || !res || !res[0]){ container.textContent='No images found.'; return; }
    gPlaces.getDetails({placeId:res[0].place_id, fields:['name','photos','url']}, (det,s2)=>{
      if(s2!=='OK' || !det){ container.textContent='No images available.'; return; }
      const grid=document.createElement('div'); grid.className='ref-grid';
      (det.photos||[]).slice(0,12).forEach(p=>{ const img=document.createElement('img'); img.loading='lazy'; img.src=p.getUrl({maxWidth:400,maxHeight:400}); img.title=det.name; img.addEventListener('click',()=>window.open(det.url,'_blank')); grid.appendChild(img); });
      container.innerHTML=''; if(grid.childElementCount) container.appendChild(grid); else container.textContent='No images.';
    });
  });
}

// Reverse Geocode
function revGeocode(lat,lon,cb){
  if(!usingGoogle || !gGeocoder){ cb(null); return; }
  gGeocoder.geocode({location:{lat,lng:lon}}, (res,status)=> cb(status==='OK'&&res[0]?res[0].formatted_address:null));
}

// ETA / Route
let myMarker=null;
function geolocate(cb){
  if(!navigator.geolocation){ alert('Geolocation not supported'); return; }
  navigator.geolocation.getCurrentPosition(pos=>{
    const pt={lat:pos.coords.latitude,lng:pos.coords.longitude};
    if(usingGoogle){
      if(!myMarker) myMarker=new google.maps.Marker({map:gmap,position:pt,icon:{path:google.maps.SymbolPath.CIRCLE,scale:5,fillColor:'#34d399',fillOpacity:1,strokeColor:'#034d36',strokeWeight:2}});
      else myMarker.setPosition(pt);
      gmap.panTo(pt);
    } else {
      if(myMarker){ lLayer.removeLayer(myMarker); }
      myMarker=L.circleMarker([pt.lat,pt.lng],{radius:6,color:'#34d399',fillColor:'#34d399',fillOpacity:1}).addTo(lLayer);
      lmap.panTo([pt.lat,pt.lng]);
    }
    cb&&cb(pt);
  }, err=>alert('Geolocation error: '+err.message), {enableHighAccuracy:true,timeout:10000,maximumAge:30000});
}
function etaToAnchor(loc){
  if(!usingGoogle){ alert('This needs Google mode. Click “Google Maps (online)” above the Light panel.'); return; }
  geolocate(pt=>{
    const a=activeAnchor(loc);
    const svc=new google.maps.DistanceMatrixService();
    svc.getDistanceMatrix({origins:[pt],destinations:[{lat:a.lat,lng:a.lon}],travelMode:'WALKING'}, (res,status)=>{
      if(status==='OK'){ const el=res.rows[0].elements[0]; alert(`Walking ETA: ${el.duration.text} • ${el.distance.text}`);} else alert('DistanceMatrix failed: '+status);
    });
  });
}
function routeToAnchor(loc){
  if(!usingGoogle){ alert('This needs Google mode. Click “Google Maps (online)” above the Light panel.'); return; }
  geolocate(pt=>{
    const a=activeAnchor(loc);
    gDirections.route({origin:pt,destination:{lat:a.lat,lng:a.lon},travelMode:'WALKING'}, (res,status)=>{
      if(status==='OK'){ gDirRenderer.setDirections(res); } else alert('Directions failed: '+status);
    });
  });
}

// UI
function makeExpandableList(items){
  const ul=document.createElement('ul'); ul.className='expand-list';
  (items||[]).forEach(it=>{
    const li=document.createElement('li'); li.className='expand-item';
    const btn=document.createElement('button'); btn.className='expand-summary'; btn.innerHTML=`<span>${it.title}</span> <span class="hint">Tap for details</span>`;
    const body=document.createElement('div'); body.className='expand-body'; body.textContent=it.detail||'';
    btn.addEventListener('click',()=> li.classList.toggle('open'));
    li.appendChild(btn); li.appendChild(body); ul.appendChild(li);
  });
  return ul;
}
function timingForBlock(dayKey,block){
  const t=TIMES[dayKey]; if(!t) return '';
  if(block==='Morning') return `Arrive 6:00–7:30 am • Civil dawn ${t.civil_dawn} • Sunrise ${t.sunrise}`;
  if(block==='Afternoon') return `Best 12:00–3:30 pm • Interiors/shade for soft contrast`;
  if(block==='Evening') return `Arrive 5:30–7:00 pm • Sunset ${t.sunset} • Civil dusk ${t.civil_dusk}`;
  if(block==='Night') return `Start 6:50–9:00 pm • Civil dusk ${t.civil_dusk} • Moonrise ${t.moonrise}`;
  return '';
}
async function cardFor(loc){
  const a=activeAnchor(loc);
  const card=document.createElement('div'); card.className='card';
  card.innerHTML=`
    <div class="card-header">
      <h3>${loc.name}</h3>
      <div class="badges"><span class="badge">Rank #${loc.rank}</span><span class="badge block-${loc.block}">${loc.block}</span></div>
    </div>
    <div class="summary-line">${dayLabelISO(state.dayMap[loc.day])} • <b>${loc.block}</b> • Bearing: ${loc.bearing}</div>
    <div class="kv">
      <div class="k">Why now</div><div>${loc.whyNow||''}</div>
      <div class="k">Timing</div><div>${timingForBlock(loc.day,loc.block)}</div>
      <div class="k">Face & light</div><div>${loc.bearing||''}</div>
      <div class="k">Gear</div><div>${loc.gear||''}</div>
    </div>
    <div class="actions">
      <button class="btnShow">Show on map</button>
      <button class="btnETA">ETA</button>
      <button class="btnRoute">Route</button>
      <a class="btnOpen" href="${gmapsOpen(a.lat,a.lon)}" target="_blank" rel="noopener">Open (anchor)</a>
      <a class="btnWalk" href="https://www.google.com/maps/dir/?api=1&destination=${a.lat},${a.lon}&travelmode=walking" target="_blank" rel="noopener">Walk to anchor</a>
    </div>
  `;
  const pset=document.createElement('div'); pset.className='pillset';
  (loc.anchors||[]).forEach((an,idx)=>{ const b=document.createElement('button'); b.className='pill'; b.textContent=an.label+(idx===loc.activeAnchor?' ✓':''); b.addEventListener('click',()=>{loc.activeAnchor=idx; saveLocal(); renderMarkers(); renderList();}); pset.appendChild(b); });
  const kvA=document.createElement('div'); kvA.className='kv'; kvA.style.marginTop='.5rem'; kvA.appendChild((()=>{const d=document.createElement('div'); d.className='k'; d.textContent='Anchor'; return d;})()); const abox=document.createElement('div'); abox.appendChild(pset); kvA.appendChild(abox); card.appendChild(kvA);

  const det=document.createElement('details'); if(state.expandAll) det.open=true; const sum=document.createElement('summary'); sum.textContent='Pins, shots, settings & reference images'; det.appendChild(sum);

  const pinsBox=document.createElement('div'); pinsBox.appendChild(makeExpandableList(loc.pins));
  const microAbs=computeMicroAbs(loc); const microPills=document.createElement('div'); microPills.className='pillset';
  microAbs.forEach(mp=>{ const a=document.createElement('a'); a.className='pill'; a.href=`https://www.google.com/maps/dir/?api=1&destination=${mp.lat},${mp.lon}&travelmode=walking`; a.target='_blank'; a.rel='noopener'; a.textContent=mp.title; microPills.appendChild(a); });
  const shotsBox=document.createElement('div'); shotsBox.appendChild(makeExpandableList(loc.shots));

  const tideDiv=document.createElement('div'); tideDiv.className='small'; tideDiv.textContent='Loading tides…'; fetchNOAATides(state.dayMap[loc.day]).then(txt=> tideDiv.textContent=txt);
  const moonDiv=document.createElement('div'); moonDiv.className='small'; const T=TIMES[loc.day]; moonDiv.textContent=`Moonrise ${T.moonrise} • Moonset ${T.moonset} • ${T.moonText}`;

  const refWrap=document.createElement('div'); refWrap.className='expand-item'; const refBtn=document.createElement('button'); refBtn.className='expand-summary'; refBtn.innerHTML='<span>Reference Images</span> <span class="hint">Tap to load</span>'; const refBody=document.createElement('div'); refBody.className='expand-body'; refBody.textContent='Loading…'; refBtn.addEventListener('click',()=>{ refWrap.classList.toggle('open'); if(refWrap.classList.contains('open')) loadReferencePhotos(refBody, loc); }); refWrap.appendChild(refBtn); refWrap.appendChild(refBody);

  const addrDiv=document.createElement('div'); addrDiv.className='small'; revGeocode(a.lat,a.lon,addr=> addrDiv.textContent=addr?`Address: ${addr}`:'');

  const kv=document.createElement('div'); kv.className='kv'; kv.style.marginTop='.5rem';
  function addKV(k,el){ const kd=document.createElement('div'); kd.className='k'; kd.textContent=k; kv.appendChild(kd); kv.appendChild(el); }
  addKV('Pins', pinsBox);
  addKV('Micro‑pins', microPills);
  addKV('Shots', shotsBox);
  addKV('Settings', (()=>{const d=document.createElement('div'); d.textContent=loc.settings||''; return d;})());
  addKV('Tides (The Battery)', tideDiv);
  addKV('Moon', moonDiv);
  addKV('Address', addrDiv);
  det.appendChild(kv); det.appendChild(document.createElement('div')).className='hr'; det.appendChild(refWrap);
  card.appendChild(det);

  card.querySelector('.btnShow').addEventListener('click',()=>{ if(usingGoogle&&gmap){ const bounds=new google.maps.LatLngBounds(); const a=activeAnchor(loc); bounds.extend({lat:a.lat,lng:a.lon}); computeMicroAbs(loc).forEach(mp=>bounds.extend({lat:mp.lat,lng:mp.lon})); gmap.fitBounds(bounds,120);} else if(lmap){ const pts=computeMicroAbs(loc).map(mp=>[mp.lat,mp.lon]); const a=activeAnchor(loc); pts.push([a.lat,a.lon]); lmap.fitBounds(pts,{padding:[120,120]}); } });
  card.querySelector('.btnETA').addEventListener('click', ()=>etaToAnchor(loc));
  card.querySelector('.btnRoute').addEventListener('click', ()=>routeToAnchor(loc));
  return card;
}

function renderLightPanels(){
  computeTimes();
  const el=document.getElementById('lightpanels'); el.innerHTML='';
  ["2025-10-03","2025-10-04"].forEach(k=>{
    const t=TIMES[k], p=document.createElement('div'); p.className='panel';
    p.innerHTML=`<div class="section-title">${dayLabelISO(state.dayMap[k])} — Light • Moon • Tides</div>
      <div class="kv">
        <div class="k">Civil dawn</div><div>${t.civil_dawn}</div>
        <div class="k">Sunrise</div><div>${t.sunrise}</div>
        <div class="k">Sunset</div><div>${t.sunset}</div>
        <div class="k">Civil dusk</div><div>${t.civil_dusk}</div>
        <div class="k">Moon</div><div>Rise ${t.moonrise} • Set ${t.moonset} • ${t.moonText}</div>
      </div>`;
    el.appendChild(p);
  });
}

function renderList(){
  const list=document.getElementById('list'); list.innerHTML='';
  const grouped=new Map();
  visibleLocations().forEach(loc=>{ const key=dayLabelISO(state.dayMap[loc.day])+" | "+loc.block; if(!grouped.has(key)) grouped.set(key,[]); grouped.get(key).push(loc); });
  for(const [key,arr] of grouped){
    const [label, block]=key.split(" | ");
    const sec=document.createElement('section'); sec.className='panel';
    sec.innerHTML=`<div class="section-title">${label} — ${block}</div>`;
    const grid=document.createElement('div'); grid.className='grid';
    arr.sort((a,b)=>a.rank-b.rank).forEach(async loc=> grid.appendChild(await cardFor(loc)));
    sec.appendChild(grid); list.appendChild(sec);
  }
  renderMarkers();
}

// Mode toggle
function toggleMapMode(mode){
  state.mapMode=mode;
  document.getElementById('modeGoogle').classList.toggle('active', mode==='google');
  document.getElementById('modeLeaflet').classList.toggle('active', mode==='leaflet');
  if(mode==='google'){
    injectGoogle().then(()=>{ initGoogle(); renderMarkers(); }).catch(()=>{ alert('Google failed to load; falling back to Leaflet.'); initLeaflet(); renderMarkers(); });
  } else { initLeaflet(); renderMarkers(); }
}

// UI init
function initUI(){
  document.getElementById('dateA').value=state.dayMap["2025-10-03"];
  document.getElementById('dateB').value=state.dayMap["2025-10-04"];
  document.getElementById('dateA').addEventListener('change',e=>{state.dayMap["2025-10-03"]=e.target.value; saveLocal(); renderLightPanels(); renderList();});
  document.getElementById('dateB').addEventListener('change',e=>{state.dayMap["2025-10-04"]=e.target.value; saveLocal(); renderLightPanels(); renderList();});
  document.querySelectorAll('input[name="day"]').forEach(cb=>cb.addEventListener('change',e=>{const v=e.target.value; if(e.target.checked) state.day.add(v); else state.day.delete(v); renderList(); renderMarkers();}));
  document.querySelectorAll('input[name="block"]').forEach(cb=>cb.addEventListener('change',e=>{const v=e.target.value; if(e.target.checked) state.blocks.add(v); else state.blocks.delete(v); renderList(); renderMarkers();}));
  const rmin=document.getElementById('rankMin'), rmax=document.getElementById('rankMax');
  [rmin,rmax].forEach(i=> i.addEventListener('input',()=>{ state.rankMin=+rmin.value; state.rankMax=+rmax.value; document.getElementById('rankLabel').textContent=`#${state.rankMin}–#${state.rankMax}`; renderList(); renderMarkers(); }));
  document.getElementById('proOnly').addEventListener('change',e=>{ state.proOnly=e.target.checked; renderList(); });
  document.getElementById('q').addEventListener('input',e=>{ state.q=e.target.value; renderList(); });
  document.getElementById('rain').addEventListener('change',e=>{ state.rain=e.target.checked; renderList(); });
  document.getElementById('wind').addEventListener('change',e=>{ state.wind=e.target.checked; renderList(); });
  document.getElementById('expandAll').addEventListener('click',()=>{ state.expandAll=true; renderList(); });
  document.getElementById('collapseAll').addEventListener('click',()=>{ state.expandAll=false; renderList(); });
  document.getElementById('exportCSV').addEventListener('click', exportCSV);
  document.getElementById('exportKML').addEventListener('click', exportKML);
  document.getElementById('print').addEventListener('click', ()=>window.print());
  document.getElementById('theme').addEventListener('click', toggleTheme);
  document.getElementById('editMode').addEventListener('click', ()=> alert('Drag pins in Google mode. Use the buttons in each card to jump to the anchor.'));
  document.getElementById('modeGoogle').addEventListener('click', ()=>toggleMapMode('google'));
  document.getElementById('modeLeaflet').addEventListener('click', ()=>toggleMapMode('leaflet'));
  document.getElementById('importJSON').addEventListener('change', e=>{ if(e.target.files[0]){ const r=new FileReader(); r.onload=()=>{ try{ const obj=JSON.parse(r.result); if(obj.LOCATIONS) LOCATIONS=obj.LOCATIONS; if(obj.state?.dayMap) state.dayMap=obj.state.dayMap; saveLocal(); renderLightPanels(); renderList(); renderMarkers(); }catch(err){ alert('Invalid JSON'); } }; r.readAsText(e.target.files[0]); } });
  document.getElementById('exportJSON').addEventListener('click', ()=>{ const blob=new Blob([JSON.stringify({LOCATIONS,state},null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='NYC_Photo_Guide_v7_1.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),2000); });
}

function toggleTheme(){
  const root=document.documentElement;
  const dark=getComputedStyle(root).getPropertyValue('--bg').trim()==='#0b1220';
  if(dark){
    root.style.setProperty('--bg','#f6f8fb'); root.style.setProperty('--panel','#ffffff'); root.style.setProperty('--card','#ffffff'); root.style.setProperty('--text','#0b1220');
    root.style.setProperty('--muted','#465a77'); root.style.setProperty('--border','#d7e1ef'); root.style.setProperty('--shadow','rgba(0,0,0,.07)');
  } else {
    root.style.setProperty('--bg','#0b1220'); root.style.setProperty('--panel','#0f172a'); root.style.setProperty('--card','#0e1426'); root.style.setProperty('--text','#e6edf6');
    root.style.setProperty('--muted','#9bb0c9'); root.style.setProperty('--border','#1f2a44'); root.style.setProperty('--shadow','rgba(0,0,0,.35)');
  }
}

// Export helpers
function exportCSV(){
  const rows=[["dayLabel","block","rank","name","activeAnchor","anchorLat","anchorLon"]];
  visibleLocations().forEach(l=>{ const a=activeAnchor(l); rows.push([dayLabelISO(state.dayMap[l.day]), l.block, l.rank, l.name, a.label, a.lat, a.lon]); });
  const csv=rows.map(r=>r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(",")).join("\n");
  const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([csv],{type:'text/plain'})); a.download='NYC_Photo_Guide_Anchors.csv'; a.click();
}
function exportKML(){
  let kml=`<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2"><Document><name>NYC Photo Pins (Anchors+Micro)</name>`;
  visibleLocations().forEach(p=>{
    const a=activeAnchor(p);
    const desc=`${dayLabelISO(state.dayMap[p.day])} • ${p.block} • Rank ${p.rank}`;
    kml+=`<Placemark><name>${p.name} — ${a.label}</name><description><![CDATA[${desc}]]></description><Point><coordinates>${a.lon},${a.lat},0</coordinates></Point></Placemark>`;
    computeMicroAbs(p).forEach(mp=>{
      const d2=`${p.name} / ${mp.title}`;
      kml+=`<Placemark><name>${p.name} — ${mp.title}</name><description><![CDATA[${d2}]]></description><Point><coordinates>${mp.lon},${mp.lat},0</coordinates></Point></Placemark>`;
    });
  });
  kml+=`</Document></kml>`;
  const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([kml],{type:'text/plain'})); a.download='NYC_Photo_Pins.kml'; a.click();
}

// Persistence
function saveLocal(){ localStorage.setItem('nyc_photo_guide_'+CFG.dataVersion, JSON.stringify({LOCATIONS, state:{dayMap:state.dayMap}})); }
function loadLocal(){ try{ const s=localStorage.getItem('nyc_photo_guide_'+CFG.dataVersion); if(s){ const o=JSON.parse(s); if(o.LOCATIONS) LOCATIONS=o.LOCATIONS; if(o.state?.dayMap) state.dayMap=o.state.dayMap; } }catch{} }

// Boot
async function init(){
  loadLocal();
  initUI();
  renderLightPanels();
  // Initialize map engine first to avoid clearLayers() errors
  try{
    await injectGoogle();
    initGoogle();
    document.getElementById('modeGoogle').classList.add('active');
  }catch{
    initLeaflet();
    document.getElementById('modeLeaflet').classList.add('active');
  }
  renderList();
}
window.addEventListener('DOMContentLoaded', init);

</script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</body>
</html>
