<!doctype html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>NYC Photo Guide</title>
    <style>
      :root {
        --bg: #0b0d10;
        --fg: #e6ecf2;
        --muted: #9fb3c8;
        --accent: #5cc8ff;
        --ok: #43d17a;
        --warn: #f7b23b;
        --danger: #ff6b6b;
        --card: #131720;
        --card-muted: #0f1320;
        --border: #263043;
        --chip: #1d2433;
      }
      [data-theme="light"]{
        --bg: #f6f8fb;
        --fg: #111827;
        --muted: #4b5563;
        --accent: #0066ff;
        --ok: #10b981;
        --warn: #d97706;
        --danger: #ef4444;
        --card: #ffffff;
        --card-muted: #f1f5f9;
        --border: #e5e7eb;
        --chip: #eef2f7;
      }
      html,body{height:100%}
      body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
      a{color:var(--accent);text-decoration:none}
      a:hover{text-decoration:underline}
      .app{display:grid;grid-template-columns:320px 1fr;grid-template-rows:auto 1fr;grid-template-areas:'hdr hdr''left right';min-height:100vh}
      header{grid-area:hdr;position:sticky;top:0;background:linear-gradient(to bottom,var(--bg),rgba(0,0,0,0));z-index:5;border-bottom:1px solid var(--border)}
      .hdr-wrap{display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;padding:.75rem 1rem}
      .title{font-weight:700;margin-right:1rem}
      .controls{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center}
      .chip{background:var(--chip);border:1px solid var(--border);border-radius:.5rem;padding:.35rem .5rem;display:inline-flex;gap:.35rem;align-items:center}
      .chip input[type="date"]{background:transparent;border:none;color:var(--fg)}
      .chip input[type="text"]{background:transparent;border:none;color:var(--fg);width:180px}
      .btn{background:var(--chip);border:1px solid var(--border);border-radius:.5rem;padding:.35rem .6rem;cursor:pointer}
      .btn[disabled]{opacity:.6;cursor:not-allowed}
      .left{grid-area:left;padding:1rem;border-right:1px solid var(--border);position:sticky;align-self:start;top:3.25rem;height:calc(100vh - 3.25rem);overflow:auto}
      .right{grid-area:right;display:grid;grid-template-columns:1fr 440px;gap:0;border-left:none}
      .list{padding:1rem;overflow:auto;max-height:calc(100vh - 3.25rem)}
      .map-wrap{position:sticky;top:3.25rem;height:calc(100vh - 3.25rem);border-left:1px solid var(--border)}
      .map-tabs{display:flex;gap:.25rem;padding:.5rem;border-bottom:1px solid var(--border);background:var(--card)}
      .tab{padding:.35rem .6rem;border:1px solid var(--border);border-radius:.5rem;background:var(--chip);cursor:pointer}
      .tab.active{outline:2px solid var(--accent)}
      #map-google,#map-leaflet{height:100%;width:100%;display:none}
      #map-google.active,#map-leaflet.active{display:block}
      .panel{background:var(--card);border:1px solid var(--border);border-radius:.75rem;margin-bottom:.75rem;overflow:hidden}
      .panel h3{margin:0;padding:.6rem .75rem;border-bottom:1px solid var(--border);font-size:1rem}
      .panel .body{padding:.75rem}
      .kvs{display:grid;grid-template-columns:1fr 1fr;gap:.5rem .75rem}
      .kv{display:flex;gap:.35rem;align-items:center;font-size:.93rem}
      .kv .k{color:var(--muted);min-width:110px}
      .card{background:var(--card);border:1px solid var(--border);border-radius:.75rem;margin:0 0 .75rem 0}
      .card .hdr{padding:.6rem .75rem;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;gap:.5rem;align-items:center}
      .badges{display:flex;gap:.35rem;align-items:center}
      .badge{background:var(--chip);border:1px solid var(--border);padding:.2rem .45rem;border-radius:999px;font-size:.78rem}
      .card .sum{padding:.5rem .75rem;color:var(--muted);font-size:.93rem;border-bottom:1px dashed var(--border)}
      .card .actions{padding:.5rem .75rem;display:flex;flex-wrap:wrap;gap:.35rem}
      .card .actions .btn{font-size:.9rem}
      .pillset{padding:.5rem .75rem;display:flex;flex-wrap:wrap;gap:.35rem}
      .pill{background:var(--chip);border:1px solid var(--border);border-radius:999px;padding:.25rem .45rem;cursor:pointer}
      .pill.active{outline:2px solid var(--accent)}
      .exp{padding:.5rem .75rem;display:none}
      .exp.open{display:block}
      .grid-photos{display:grid;grid-template-columns:repeat(3,1fr);gap:.25rem;margin-top:.5rem}
      .grid-photos img{width:100%;height:92px;object-fit:cover;border-radius:.4rem;border:1px solid var(--border);}
      .toast{position:fixed;bottom:1rem;right:1rem;z-index:99;background:var(--card);border:1px solid var(--border);padding:.6rem .8rem;border-radius:.6rem;box-shadow:0 6px 20px rgba(0,0,0,.3);}
      .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
      .row{display:flex;gap:.25rem;align-items:center}
      .flex{display:flex;gap:.5rem;align-items:center}
      .rightcol{border-left:1px solid var(--border);display:flex;flex-direction:column}
      .map-head{display:flex;justify-content:space-between;align-items:center;padding:.5rem;border-bottom:1px solid var(--border)}
      .small{font-size:.85rem;color:var(--muted)}
      .muted{color:var(--muted)}
      .danger{color:var(--danger)}
      .ok{color:var(--ok)}
      .warn{color:var(--warn)}
      .hr{height:1px;background:var(--border);margin:.5rem 0}
      .range{display:flex;gap:.35rem;align-items:center}
      .range input[type="range"]{width:120px}
      .sticky-title{position:sticky;top:3.25rem;background:var(--bg);z-index:3;padding:.5rem 1rem;border-bottom:1px solid var(--border)}
      .section-title{margin:.5rem 0 .25rem;font-size:.95rem;color:var(--muted)}
      .hidden{display:none !important}
    </style>
  </head>
  <body>
    <div class="app" role="application">
      <header>
        <div class="hdr-wrap">
          <div class="title" aria-label="App Title">ðŸ“· NYC Photo Guide</div>
          <div class="controls" role="toolbar" aria-label="Header controls">
            <span class="chip" title="Day A"><label for="dayA" class="sr-only">Day A</label><input id="dayA" type="date"/></span>
            <span class="chip" title="Day B"><label for="dayB" class="sr-only">Day B</label><input id="dayB" type="date"/></span>
            <span class="chip" title="Day filters">
              <label><input id="showA" type="checkbox" checked/> Fri</label>
              <label><input id="showB" type="checkbox" checked/> Sat</label>
            </span>
            <span class="chip" title="Block filters">
              <label><input id="fMorning" type="checkbox" checked/> Morning</label>
              <label><input id="fAfternoon" type="checkbox" checked/> Afternoon</label>
              <label><input id="fEvening" type="checkbox" checked/> Evening</label>
              <label><input id="fNight" type="checkbox" checked/> Night</label>
            </span>
            <span class="chip range" title="Rank range">
              <span class="small" id="rankLabel">#1â€“#5</span>
              <input id="rankMin" type="range" min="1" max="5" step="1" value="1" aria-label="Min rank"/>
              <input id="rankMax" type="range" min="1" max="5" step="1" value="5" aria-label="Max rank"/>
            </span>
            <span class="chip" title="Search">
              ðŸ”Ž <label for="search" class="sr-only">Search</label><input id="search" type="text" placeholder="Search locationsâ€¦"/>
            </span>
            <button id="expandAll" class="btn">Expand all</button>
            <button id="collapseAll" class="btn">Collapse all</button>
            <button id="exportCSV" class="btn">Export CSV</button>
            <button id="exportKML" class="btn">Export KML</button>
            <button id="print" class="btn">Print</button>
            <button id="exportJSON" class="btn">Export JSON</button>
            <label class="btn" title="Import JSON">
              Import JSON<input id="importJSON" type="file" accept="application/json" class="hidden"/>
            </label>
            <button id="theme" class="btn" aria-pressed="true">Theme</button>
            <label class="btn" title="Toggle anchor edit mode">
              <input id="editAnchors" type="checkbox"/> Edit anchors
            </label>
          </div>
        </div>
      </header>
      <aside class="left" aria-label="Light and Moon Panels">
        <div id="panels"></div>
      </aside>
      <main class="right">
        <div class="list" id="list" aria-live="polite"></div>
        <div class="rightcol">
          <div class="map-head">
            <div class="map-tabs" role="tablist" aria-label="Map mode">
              <button id="tabGoogle" class="tab" role="tab" aria-controls="map-google" aria-selected="false">Google</button>
              <button id="tabLeaflet" class="tab active" role="tab" aria-controls="map-leaflet" aria-selected="true">Leaflet</button>
            </div>
            <div class="small">Switch engine anytime. Routes available in Google mode.</div>
          </div>
          <div class="map-wrap">
            <div id="map-google" aria-label="Google Map"></div>
            <div id="map-leaflet" aria-label="Leaflet Map" class="active"></div>
          </div>
        </div>
      </main>
    </div>
    <div id="toast" class="toast hidden" role="status" aria-live="polite"></div>
    
<script type="module">
const SRC = {
  app: `// /public/app.js
import { loadConfig } from './config.js';
import { LOCATIONS as RAW } from './data/locations.js';
import { computeSunTimes, computeMoonInfo } from './lib/sunmoon.js';
import { loadGoogle, hasGoogle } from './lib/googleLoader.js';
import * as GMap from './map-google.js';
import * as LMap from './map-leaflet.js';

// --- State & persistence ---
const defaultDays = deduceDefaultDays(RAW);
const state = {
  dayA: defaultDays[0],
  dayB: defaultDays[1],
  showDays: { [defaultDays[0]]: true, [defaultDays[1]]: true },
  blocks: { Morning:true, Afternoon:true, Evening:true, Night:true },
  rankMin: 1, rankMax: 5,
  search: '',
  mapMode: 'leaflet', // default offline-friendly
  editAnchors: false,
  tidesCache: {}, // YYYY-MM-DD -> string
};

const STORAGE_KEY = 'nyc-photo-guide:v1';
const LOC_KEY = 'nyc-photo-guide:locations';
let LOCATIONS = hydrateLocations(RAW);

function deduceDefaultDays(arr){
  // pick the two distinct day strings present in data (sorted)
  const days = Array.from(new Set(arr.map(x=>x.day))).sort();
  return [days[0], days[1] ?? days[0]];
}

function hydrateLocations(raw){
  const cloned = JSON.parse(JSON.stringify(raw));
  // Merge local edits if any
  try{
    const saved = JSON.parse(localStorage.getItem(LOC_KEY) || 'null');
    if (Array.isArray(saved)) {
      const byId = Object.fromEntries(cloned.map(x=>[x.id,x]));
      saved.forEach(item => { if (byId[item.id]) byId[item.id].anchors = item.anchors; });
    }
  }catch{}
  // Precompute micro-pin absolute coords for active anchor
  cloned.forEach(loc => computeMicroAbs(loc));
  return cloned;
}

function computeMicroAbs(loc){
  const a = loc.anchors[loc.activeAnchor ?? 0];
  const out = [];
  const lat = a.lat, lon=a.lon;
  const toRad = (d)=>d*Math.PI/180, toDeg = (r)=>r*180/Math.PI;
  const cos = Math.cos, sin = Math.sin;
  const metersPerDegLat = 111111;
  const metersPerDegLon = 111111 * Math.cos(toRad(lat));
  (loc.micro || []).forEach(m => {
    const b = (m.bearing ?? 0) * Math.PI/180;
    const dlat = (m.r * Math.cos(b)) / metersPerDegLat;
    const dlon = (m.r * Math.sin(b)) / metersPerDegLon;
    const lat2 = lat + dlat;
    const lon2 = lon + dlon;
    // short arrow direction from micro-pin in bearing dir (~16 m)
    const arrowLen = 16;
    const dlat2 = (arrowLen * Math.cos(b)) / metersPerDegLat;
    const dlon2 = (arrowLen * Math.sin(b)) / metersPerDegLon;
    out.push({ title: m.title, detail: m.detail, lat:lat2, lon:lon2, lat2: lat2+dlat2, lon2: lon2+dlon2 });
  });
  loc.__microAbs = out;
}

// Persist local edits of anchors
function persistAnchors(){
  try{
    const subset = LOCATIONS.map(x=>({ id:x.id, anchors:x.anchors }));
    localStorage.setItem(LOC_KEY, JSON.stringify(subset));
  }catch{}
}

function saveState(){
  try{
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      dayA: state.dayA, dayB: state.dayB, showDays: state.showDays,
      blocks: state.blocks, rankMin: state.rankMin, rankMax: state.rankMax, theme: document.documentElement.getAttribute('data-theme'),
      mapMode: state.mapMode
    }));
  }catch{}
}
function loadState(){
  try{
    const s = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null');
    if (s){
      Object.assign(state, s);
      if (s.theme) document.documentElement.setAttribute('data-theme', s.theme);
    }
  }catch{}
}
loadState();

// --- Boot ---
const cfg = await loadConfig();
await LMap.initLeaflet();
wireHeader();
renderPanels();
renderList();
await renderMap();

// --- Header wiring ---
function wireHeader(){
  const $ = (id)=>document.getElementById(id);
  $('dayA').value = state.dayA;
  $('dayB').value = state.dayB;
  $('showA').checked = !!state.showDays[state.dayA];
  $('showB').checked = !!state.showDays[state.dayB];
  $('fMorning').checked = state.blocks.Morning;
  $('fAfternoon').checked = state.blocks.Afternoon;
  $('fEvening').checked = state.blocks.Evening;
  $('fNight').checked = state.blocks.Night;
  $('rankMin').value = state.rankMin;
  $('rankMax').value = state.rankMax;
  updateRankLabel();
  $('tabGoogle').classList.toggle('active', state.mapMode==='google');
  $('tabLeaflet').classList.toggle('active', state.mapMode==='leaflet');
  document.getElementById('map-google').classList.toggle('active', state.mapMode==='google');
  document.getElementById('map-leaflet').classList.toggle('active', state.mapMode==='leaflet');
  $('editAnchors').checked = state.editAnchors;

  $('dayA').addEventListener('change', (e)=>{ state.dayA = e.target.value; renderPanels(); renderList(); renderMap(); saveState(); });
  $('dayB').addEventListener('change', (e)=>{ state.dayB = e.target.value; renderPanels(); renderList(); renderMap(); saveState(); });
  $('showA').addEventListener('change', (e)=>{ state.showDays[state.dayA] = e.target.checked; renderList(); renderMap(); saveState(); });
  $('showB').addEventListener('change', (e)=>{ state.showDays[state.dayB] = e.target.checked; renderList(); renderMap(); saveState(); });
  $('fMorning').addEventListener('change', (e)=>{ state.blocks.Morning = e.target.checked; renderList(); renderMap(); saveState(); });
  $('fAfternoon').addEventListener('change', (e)=>{ state.blocks.Afternoon = e.target.checked; renderList(); renderMap(); saveState(); });
  $('fEvening').addEventListener('change', (e)=>{ state.blocks.Evening = e.target.checked; renderList(); renderMap(); saveState(); });
  $('fNight').addEventListener('change', (e)=>{ state.blocks.Night = e.target.checked; renderList(); renderMap(); saveState(); });
  $('rankMin').addEventListener('input', onRankChange);
  $('rankMax').addEventListener('input', onRankChange);
  $('search').addEventListener('input', (e)=>{ state.search = e.target.value.toLowerCase(); renderList(); renderMap(); });
  $('expandAll').addEventListener('click', ()=>{ document.querySelectorAll('.exp').forEach(x=>x.classList.add('open')); });
  $('collapseAll').addEventListener('click', ()=>{ document.querySelectorAll('.exp').forEach(x=>x.classList.remove('open')); });
  $('exportCSV').addEventListener('click', exportCSV);
  $('exportKML').addEventListener('click', exportKML);
  $('exportJSON').addEventListener('click', exportJSON);
  $('importJSON').addEventListener('change', importJSON);
  $('print').addEventListener('click', ()=>window.print());
  $('theme').addEventListener('click', toggleTheme);
  $('tabGoogle').addEventListener('click', async ()=>{ state.mapMode='google'; await renderMap(true); saveState(); });
  $('tabLeaflet').addEventListener('click', async ()=>{ state.mapMode='leaflet'; await renderMap(true); saveState(); });
  $('editAnchors').addEventListener('change', async (e)=>{
    state.editAnchors = e.target.checked;
    if (state.mapMode==='google') GMap.setEditMode(state.editAnchors);
  });

  window.addEventListener('keydown', (e)=>{
    if (e.key==='Escape') hideToast();
    if (e.key==='Enter' && document.activeElement && document.activeElement.classList.contains('pill')){
      document.activeElement.click();
    }
  });
}

function onRankChange(){
  const min = parseInt(document.getElementById('rankMin').value, 10);
  const max = parseInt(document.getElementById('rankMax').value, 10);
  // keep thumbs ordered
  if (min > max){ if (this.id==='rankMin') document.getElementById('rankMax').value = String(min); else document.getElementById('rankMin').value = String(max); }
  state.rankMin = parseInt(document.getElementById('rankMin').value,10);
  state.rankMax = parseInt(document.getElementById('rankMax').value,10);
  updateRankLabel();
  renderList(); renderMap(); saveState();
}
function updateRankLabel(){ document.getElementById('rankLabel').textContent = \`#${state.rankMin}â€“#${state.rankMax}\`; }

function toggleTheme(){
  const html = document.documentElement;
  const now = html.getAttribute('data-theme')==='dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', now);
  saveState();
}

// --- Panels (Light/Moon/Tides) ---
async function renderPanels(){
  const panels = document.getElementById('panels');
  panels.innerHTML = '';
  for (const day of [state.dayA, state.dayB]){
    const d = new Date(day+'T00:00:00');
    const sun = computeSunTimes(d, 40.7128, -74.0060);
    const moon = computeMoonInfo(d, 40.7128, -74.0060);
    const tides = await getTidesHiLo(day).catch(()=>null);
    const panel = document.createElement('div');
    panel.className = 'panel';
    panel.innerHTML = \`
      <h3>Light / Moon / Tides â€” ${day}</h3>
      <div class="body">
        <div class="kvs">
          <div class="kv"><div class="k">Civil dawn</div><div>${fmtTime(sun.civilDawn)}</div></div>
          <div class="kv"><div class="k">Sunrise</div><div>${fmtTime(sun.sunrise)}</div></div>
          <div class="kv"><div class="k">Sunset</div><div>${fmtTime(sun.sunset)}</div></div>
          <div class="kv"><div class="k">Civil dusk</div><div>${fmtTime(sun.civilDusk)}</div></div>
          <div class="kv"><div class="k">Moonrise</div><div>${fmtTime(moon.rise)}</div></div>
          <div class="kv"><div class="k">Moonset</div><div>${fmtTime(moon.set)}</div></div>
          <div class="kv"><div class="k">Moon illum.</div><div>${moon.illuminationPct?.toFixed(1) ?? 'â€”'}%</div></div>
          <div class="kv"><div class="k">Battery tides</div><div>${tides ?? '<span class="muted">â€”</span>'}</div></div>
        </div>
      </div>\`;
    panels.appendChild(panel);
  }
}

function fmtTime(d){
  if (!(d instanceof Date) || isNaN(d)) return 'â€”';
  const dt = new Date(d);
  const hh = dt.getHours().toString().padStart(2,'0');
  const mm = dt.getMinutes().toString().padStart(2,'0');
  return \`${hh}:${mm}\`;
}

async function getTidesHiLo(dayStr){
  if (state.tidesCache[dayStr]) return state.tidesCache[dayStr];
  const yyyymmdd = dayStr.replaceAll('-','');
  const url = \`https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?product=predictions&begin_date=${yyyymmdd}&end_date=${yyyymmdd}&datum=MLLW&station=8518750&time_zone=lst_ldt&interval=hilo&units=english&format=json\`;
  try{
    const r = await fetch(url);
    if (!r.ok) throw new Error('NOAA HTTP '+r.status);
    const j = await r.json();
    if (Array.isArray(j?.predictions) && j.predictions.length){
      const parts = j.predictions.map(p => {
        const t = p.t.split(' ')[1].slice(0,5);
        return \`${t} ${p.type}\`;
      });
      const s = parts.join(' â€¢ ');
      state.tidesCache[dayStr] = s;
      return s;
    }
    throw new Error('NOAA empty');
  }catch(e){
    console.warn('NOAA tides failed', e);
    return 'Open NOAA high/low';
  }
}

// --- List rendering ---
function renderList(){
  const list = document.getElementById('list');
  const visible = filterLocations();
  list.innerHTML = '';

  // Group by day then block
  const groups = {};
  visible.forEach(loc => {
    const k = loc.day+'|'+loc.block;
    (groups[k] ||= []).push(loc);
  });
  const order = ['Morning','Afternoon','Evening','Night'];

  Object.keys(groups).sort((a,b)=>{
    const [da,ba] = a.split('|'); const [db,bb] = b.split('|');
    if (da!==db) return da.localeCompare(db);
    return order.indexOf(ba) - order.indexOf(bb);
  }).forEach(key => {
    const [day, block] = key.split('|');
    const h = document.createElement('div');
    h.className = 'sticky-title';
    h.innerHTML = \`<div class="section-title">${day} â€¢ ${block}</div>\`;
    list.appendChild(h);
    groups[key].sort((a,b)=>a.rank - b.rank).forEach(loc => list.appendChild(renderCard(loc)));
  });
}

function filterLocations(){
  return LOCATIONS.filter(loc => {
    if (!state.showDays[loc.day]) return false;
    if (!state.blocks[loc.block]) return false;
    if (loc.rank < state.rankMin || loc.rank > state.rankMax) return false;
    if (state.search){
      const hay = [loc.name, loc.bearing, loc.whyNow, loc.gear, loc.settings, JSON.stringify(loc.pins), JSON.stringify(loc.shots)].join(' ').toLowerCase();
      if (!hay.includes(state.search)) return false;
    }
    return true;
  });
}

function renderCard(loc){
  const card = document.createElement('section');
  card.className = 'card';
  card.id = 'card-'+loc.id;
  const anchor = loc.anchors[loc.activeAnchor ?? 0];
  const sum = \`${loc.day} â€¢ ${loc.block} â€¢ ${loc.bearing}\`;

  card.innerHTML = \`
    <div class="hdr">
      <div>${loc.name}</div>
      <div class="badges">
        <span class="badge">Rank #${loc.rank}</span>
        <span class="badge">${loc.block}</span>
      </div>
    </div>
    <div class="sum">${sum}</div>
    <div class="actions">
      <button class="btn" data-act="show">Show on map</button>
      <button class="btn" data-act="eta">ETA</button>
      <button class="btn" data-act="route">Route</button>
      <a class="btn" href="https://www.google.com/maps/search/?api=1&query=${anchor.lat},${anchor.lon}" target="_blank" rel="noopener">Open (anchor)</a>
      <a class="btn" href="https://www.google.com/maps/dir/?api=1&destination=${anchor.lat},${anchor.lon}&travelmode=walking" target="_blank" rel="noopener">Walk to anchor</a>
    </div>
    <div class="pillset" role="tablist" aria-label="Anchors">
      ${loc.anchors.map((a,i)=>\`<button class="pill ${i===loc.activeAnchor?'active':''}" data-p="anchor" data-idx="${i}" aria-selected="${i===loc.activeAnchor}">Anchor: ${a.label}</button>\`).join('')}
    </div>
    <div class="pillset" role="tablist" aria-label="Micro-pins">
      ${(loc.__microAbs||[]).map((m,i)=>{
        const url = \`https://www.google.com/maps/dir/?api=1&destination=${m.lat},${m.lon}&travelmode=walking\`;
        return \`<a class="pill" href="${url}" target="_blank" rel="noopener" data-p="micro" data-idx="${i}" title="${m.detail||''}">${m.title} â†—</a>\`;
      }).join('')}
    </div>
    <div class="exp" id="exp-${loc.id}">
      <div class="hr"></div>
      <div class="kvs">
        <div class="kv"><div class="k">Why now</div><div>${loc.whyNow}</div></div>
        <div class="kv"><div class="k">Timing</div><div>${loc.settings}</div></div>
        <div class="kv"><div class="k">Face & light</div><div>${loc.bearing}</div></div>
        <div class="kv"><div class="k">Gear</div><div>${loc.gear}</div></div>
      </div>
      <div class="hr"></div>
      <div><strong>Pins</strong><ul>${loc.pins.map(p=>\`<li>${p.title} â€” ${p.detail}</li>\`).join('')}</ul></div>
      <div><strong>Shots</strong><ol>${loc.shots.map(s=>\`<li>${s.title} â€” ${s.detail}</li>\`).join('')}</ol></div>
      <div class="hr"></div>
      <div class="row">
        <button class="btn" data-act="addr">Show address</button>
        <button class="btn" data-act="photos">Reference Images</button>
        <span class="small muted">Max 12; loaded on demand</span>
      </div>
      <div class="grid-photos" id="photos-${loc.id}"></div>
      <div class="small" id="addr-${loc.id}"></div>
    </div>
  \`;

  // Card behaviors
  card.querySelectorAll('[data-act]').forEach(el => el.addEventListener('click', ev => onCardAction(ev, loc)));
  card.querySelectorAll('[data-p="anchor"]').forEach(el => el.addEventListener('click', ev => onAnchorSelect(ev, loc)));
  // Expand/Collapse by clicking header
  card.querySelector('.hdr').addEventListener('click', ()=>{
    const ex = card.querySelector('.exp');
    ex.classList.toggle('open');
  });
  return card;
}

function onAnchorSelect(ev, loc){
  const idx = Number(ev.currentTarget.getAttribute('data-idx'));
  loc.activeAnchor = idx;
  computeMicroAbs(loc);
  // update UI pills
  document.querySelectorAll(\`#card-${loc.id} [data-p="anchor"]\`).forEach((b,i)=>{
    const sel = i===idx; b.classList.toggle('active', sel); b.setAttribute('aria-selected', sel);
  });
  // refresh micro-pin pillset
  const pillset = document.querySelector(\`#card-${loc.id} .pillset[aria-label="Micro-pins"]\`);
  pillset.innerHTML = (loc.__microAbs||[]).map((m,i)=>{
    const url = \`https://www.google.com/maps/dir/?api=1&destination=${m.lat},${m.lon}&travelmode=walking\`;
    return \`<a class="pill" href="${url}" target="_blank" rel="noopener" data-p="micro" data-idx="${i}" title="${m.detail||''}">${m.title} â†—</a>\`;
  }).join('');
  renderMap(); // re-render markers and arrows
}

async function onCardAction(ev, loc){
  const act = ev.currentTarget.getAttribute('data-act');
  const a = loc.anchors[loc.activeAnchor ?? 0];
  if (act==='show'){
    await renderMap();
    fitOnMap(loc);
  } else if (act==='eta' || act==='route'){
    if (state.mapMode!=='google') {
      showToast('Route requires Google mode. Switch to Google tab.');
      return;
    }
    // Ensure Google map is ready
    await ensureGoogleMap();
    getPosition().then(async pos => {
      const google = window.google;
      try{
        const result = await GMap.distanceAndRoute(google, { lat: pos.coords.latitude, lng: pos.coords.longitude }, { lat: a.lat, lng: a.lon }, act==='route');
        const dist = result.distance?.text || 'â€”', dur = result.duration?.text || 'â€”';
        showToast(\`Walk: ${dist} â€¢ ${dur}\`);
      }catch(e){
        console.warn(e);
        showToast('Could not compute route/ETA.');
      }
    }).catch(err => {
      console.warn('Geolocation denied', err);
      showToast('Geolocation needed for ETA/Route.');
    });
  } else if (act==='addr'){
    await ensureGoogleMap();
    try{
      const geocoder = new window.google.maps.Geocoder();
      geocoder.geocode({ location: { lat:a.lat, lng: a.lon } }, (results, status)=>{
        const el = document.getElementById('addr-'+loc.id);
        if (status==='OK' && results?.[0]) el.textContent = results[0].formatted_address;
        else el.innerHTML = '<span class="muted">â€”</span>';
      });
    }catch{
      document.getElementById('addr-'+loc.id).innerHTML = '<span class="muted">â€”</span>';
    }
  } else if (act==='photos'){
    const grid = document.getElementById('photos-'+loc.id);
    if (grid.dataset.loaded) { grid.classList.toggle('hidden'); return; }
    grid.dataset.loaded = '1';
    // Requires Places library; we will call Nearby Search with keyword
    try{
      await ensureGoogleMap();
      const service = new google.maps.places.PlacesService(document.createElement('div'));
      const request = {
        location: { lat: a.lat, lng: a.lon },
        radius: 600,
        keyword: loc.name
      };
      service.nearbySearch(request, (results, status)=>{
        if (status!=='OK' || !results?.length){
          grid.innerHTML = '<div class="small muted">No images found.</div>';
          return;
        }
        const photos = [];
        for (const r of results){
          if (Array.isArray(r.photos)){
            for (const p of r.photos){
              try{
                const url = p.getUrl({maxWidth:400,maxHeight:400});
                if (url) photos.push(url);
                if (photos.length>=12) break;
              }catch{}
            }
          }
          if (photos.length>=12) break;
        }
        if (!photos.length) grid.innerHTML = '<div class="small muted">No images found.</div>';
        else grid.innerHTML = photos.map(u=>\`<img loading="lazy" alt="Reference photo" src="${u}"/>\`).join('');
      });
    }catch(e){
      console.warn('Places failed', e);
      grid.innerHTML = '<div class="small muted">Could not load images.</div>';
    }
  }
}

function showToast(msg){
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.remove('hidden');
  clearTimeout(showToast._timer);
  showToast._timer = setTimeout(()=> t.classList.add('hidden'), 5000);
}
function hideToast(){ document.getElementById('toast').classList.add('hidden'); }

function getPosition(){
  return new Promise((res, rej)=>{
    if (!navigator.geolocation) return rej(new Error('No geolocation'));
    navigator.geolocation.getCurrentPosition(res, rej, { enableHighAccuracy:true, timeout:10000, maximumAge:0 });
  });
}

// --- Map engine management ---
async function renderMap(force=false){
  const visible = filterLocations();
  if (state.mapMode==='google'){
    try{
      const google = await ensureGoogleMap(); // loads and init if needed
      GMap.renderMarkers(google, visible, onAnchorMoved);
    }catch(e){
      console.warn('Google map failed, switching to Leaflet', e);
      state.mapMode='leaflet';
      document.getElementById('tabGoogle').classList.remove('active');
      document.getElementById('tabLeaflet').classList.add('active');
      document.getElementById('map-google').classList.remove('active');
      document.getElementById('map-leaflet').classList.add('active');
      await ensureLeafletMap(true);
      LMap.renderMarkers(visible);
    }
  } else {
    await ensureLeafletMap(force);
    LMap.renderMarkers(visible);
  }
}

async function ensureGoogleMap(){
  // Create if missing
  if (!GMap.isReady()){
    const key = (await loadConfig()).GOOGLE_MAPS_API_KEY || '';
    document.getElementById('map-leaflet').classList.remove('active');
    document.getElementById('map-google').classList.add('active');
    document.getElementById('tabLeaflet').classList.remove('active');
    document.getElementById('tabGoogle').classList.add('active');
    await GMap.initGoogleMap(key);
    GMap.setEditMode(state.editAnchors);
  }
  return window.google;
}

async function ensureLeafletMap(force=false){
  if (force){ LMap.teardown(); }
  if (!document.getElementById('map-leaflet').classList.contains('active')){
    document.getElementById('map-google').classList.remove('active');
    document.getElementById('map-leaflet').classList.add('active');
    document.getElementById('tabGoogle').classList.remove('active');
    document.getElementById('tabLeaflet').classList.add('active');
  }
  // If map already exists, we assume LMap handles its own state
  if (!document.querySelector('#map-leaflet .leaflet-pane')){
    await LMap.initLeaflet();
  }
}

function fitOnMap(loc){
  if (state.mapMode==='google') GMap.fitOne(window.google, loc);
  else LMap.fitOne(loc);
}

function onAnchorMoved(id, lat, lon){
  const loc = LOCATIONS.find(x=>x.id===id);
  if (!loc) return;
  const anchor = loc.anchors[loc.activeAnchor ?? 0];
  anchor.lat = lat; anchor.lon = lon;
  computeMicroAbs(loc);
  persistAnchors();
  renderMap();
}

// --- Exporters ---
function download(filename, text, mime='text/plain'){
  const blob = new Blob([text], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  setTimeout(()=> URL.revokeObjectURL(url), 1000);
}

function exportCSV(){
  const rows = [['id','name','day','block','rank','bearing','anchor_label','lat','lon']];
  LOCATIONS.forEach(loc => {
    const a = loc.anchors[loc.activeAnchor ?? 0];
    rows.push([loc.id, loc.name, loc.day, loc.block, loc.rank, loc.bearing, a.label, a.lat, a.lon]);
    (loc.__microAbs||[]).forEach(m => rows.push([loc.id+':micro', m.title, loc.day, loc.block, loc.rank, '', 'micro', m.lat, m.lon]));
  });
  const csv = rows.map(r => r.map(v => String(v).replaceAll('"','""')).map(v=>\`"${v}"\`).join(',')).join('\\n');
  download('nyc-photo-guide.csv', csv, 'text/csv');
}

function exportKML(){
  const placemarks = LOCATIONS.map(loc => {
    const a = loc.anchors[loc.activeAnchor ?? 0];
    const micro = (loc.__microAbs||[]).map(m => \`
      <Placemark><name>${xmlEscape(m.title)}</name>
        <Point><coordinates>${m.lon},${m.lat},0</coordinates></Point>
      </Placemark>\`).join('');
    return \`
    <Folder><name>${xmlEscape(loc.name)}</name>
      <Placemark><name>${xmlEscape(loc.name)} (Anchor: ${xmlEscape(a.label)})</name>
        <Point><coordinates>${a.lon},${a.lat},0</coordinates></Point>
      </Placemark>
      ${micro}
    </Folder>\`;
  }).join('');
  const kml = \`<?xml version="1.0" encoding="UTF-8"?>
  <kml xmlns="http://www.opengis.net/kml/2.2">
    <Document><name>NYC Photo Guide</name>${placemarks}</Document>
  </kml>\`;
  download('nyc-photo-guide.kml', kml, 'application/vnd.google-earth.kml+xml');
}

function xmlEscape(s){ return String(s).replace(/[<>&'"]/g, c=>({'<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;'}[c])); }

function exportJSON(){
  const payload = { LOCATIONS, state: { dayMap: state.showDays } };
  download('nyc-photo-guide.json', JSON.stringify(payload, null, 2), 'application/json');
}

async function importJSON(ev){
  const file = ev.target.files?.[0];
  if (!file) return;
  try{
    const text = await file.text();
    const data = JSON.parse(text);
    if (Array.isArray(data.LOCATIONS)) {
      LOCATIONS = data.LOCATIONS;
      LOCATIONS.forEach(loc => computeMicroAbs(loc));
      localStorage.setItem(LOC_KEY, JSON.stringify(LOCATIONS.map(l=>({id:l.id,anchors:l.anchors}))));
    }
    if (data.state?.dayMap) state.showDays = data.state.dayMap;
    renderPanels(); renderList(); renderMap(); saveState();
    showToast('JSON imported.');
  }catch(e){
    console.warn('Import failed', e);
    showToast('Import failed.');
  } finally {
    ev.target.value = '';
  }
}

// --- Utils ---
async function ensureGoogle(){
  if (!hasGoogle()){
    const key = (await loadConfig()).GOOGLE_MAPS_API_KEY || '';
    await loadGoogle(key);
  }
}

window.__NYC_APP__ = { state, LOCATIONS, renderMap, renderList, renderPanels }; // for debugging
`,
  config: `// /public/config.js
export async function loadConfig() {
  // Priority: runtime window._ENV > /env.json > empty string (expect build-time injection)
  const out = { GOOGLE_MAPS_API_KEY: '' };
  try {
    if (window._ENV && window._ENV.GOOGLE_MAPS_API_KEY) {
      out.GOOGLE_MAPS_API_KEY = window._ENV.GOOGLE_MAPS_API_KEY;
      return out;
    }
  } catch {}
  try {
    const r = await fetch('./env.json', { cache: 'no-store' });
    if (r.ok) {
      const j = await r.json();
      if (j && typeof j.GOOGLE_MAPS_API_KEY === 'string') {
        out.GOOGLE_MAPS_API_KEY = j.GOOGLE_MAPS_API_KEY;
      }
    }
  } catch (e) {
    console.warn('No env.json found; expecting build-time injection via .env');
  }
  return out;
}
`,
  locations: `// /public/data/locations.js
export let LOCATIONS = [];
try {
  // Modern browsers support JSON modules with import assertions.
  const mod = await import('../locations.json', { assert: { type: 'json' } });
  LOCATIONS = Array.isArray(mod) ? mod : (mod.default ?? mod);
} catch (err) {
  console.warn('JSON import failed; falling back to fetch', err);
  const resp = await fetch('../locations.json');
  LOCATIONS = await resp.json();
}
`,
  googleLoader: `// /public/lib/googleLoader.js
let _googlePromise = null;
let _googleFailed = false;

export function loadGoogle(key) {
  if (_googleFailed) {
    return Promise.reject(new Error('Google previously failed to load'));
  }
  if (window.google && window.google.maps) return Promise.resolve(window.google);
  if (_googlePromise) return _googlePromise;

  _googlePromise = new Promise((resolve, reject) => {
    const scriptId = 'gmaps-sdk';
    if (document.getElementById(scriptId)) {
      // If script tag exists but google not yet ready, wait for onload.
      return;
    }
    const s = document.createElement('script');
    s.id = scriptId;
    const libs = 'places';
    s.src = \`https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(key)}&libraries=${libs}\`;
    s.async = true;
    s.onerror = () => {
      _googleFailed = true;
      reject(new Error('Google Maps failed to load'));
    };
    s.onload = () => {
      if (window.google && window.google.maps) resolve(window.google);
      else {
        _googleFailed = true;
        reject(new Error('Google Maps SDK did not initialize'));
      }
    };
    document.head.appendChild(s);
  });
  return _googlePromise;
}

export function hasGoogle() {
  return !!(window.google && window.google.maps);
}

export function markGoogleFailed() { _googleFailed = true; }
`,
  sunmoon: `// /public/lib/sunmoon.js
// Lightweight solar & lunar calculations for NYC Photo Guide.
// Not astronomical-grade; adequate for planner UI. Missing values are returned as null.

const RAD = Math.PI / 180;
function toJulian(date){
  return date / 86400000 - 0.5 + 2440587.5;
}
function fromJulian(j){ return new Date((j + 0.5 - 2440587.5) * 86400000); }
function toDays(date){ return toJulian(date) - 2451545; } // days since J2000

// Solar position helpers (NOAA / Meeus approximations)
function solarMeanAnomaly(d){ return RAD * (357.5291 + 0.98560028 * d); }
function eclipticLongitude(M){
  const C = RAD*(1.9148 * Math.sin(M) + 0.0200 * Math.sin(2*M) + 0.0003 * Math.sin(3*M));
  const P = RAD*102.9372; // perihelion of the Earth
  return M + C + P + Math.PI;
}
function rightAscension(l, b){
  const e = RAD*23.4397;
  return Math.atan2(Math.sin(l) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(l));
}
function declination(l, b){
  const e = RAD*23.4397;
  return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(l));
}
function azimuth(H, phi, dec){
  return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(dec) * Math.cos(phi));
}
function altitude(H, phi, dec){
  return Math.asin(Math.sin(phi) * Math.sin(dec) + Math.cos(phi) * Math.cos(dec) * Math.cos(H));
}
function siderealTime(d, lw){
  return RAD*(280.16 + 360.9856235 * d) - lw;
}
function hourAngle(h, phi, d){
  return Math.acos((Math.sin(h) - Math.sin(phi) * Math.sin(d)) / (Math.cos(phi) * Math.cos(d)));
}

const J0 = 0.0009;
function julianCycle(d, lw){ return Math.round(d - J0 - lw / (2*Math.PI)); }
function approxTransit(Ht, lw, n){ return J0 + (Ht + lw) / (2*Math.PI) + n; }
function solarTransitJ(ds, M, L){ return 2451545 + ds + 0.0053*Math.sin(M) - 0.0069*Math.sin(2*L); }

function getSetJ(h, phi, dec, lw, n, M, L){
  const w = hourAngle(h, phi, dec);
  const a = approxTransit(w, lw, n);
  return solarTransitJ(a, M, L);
}

export function computeSunTimes(date, lat=40.7128, lon=-74.0060) {
  // Returns civil dawn, sunrise, sunset, civil dusk (local)
  try{
    const d = toDays(new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate())));
    const lw = RAD * -lon;
    const phi = RAD * lat;
    const M = solarMeanAnomaly(d);
    const L = eclipticLongitude(M);
    const dec = declination(L, 0);
    const n = julianCycle(d, lw);
    const Jnoon = solarTransitJ(approxTransit(0, lw, n), M, L);

    const h0 = -0.833 * RAD; // sunrise/sunset
    const hc = -6 * RAD;     // civil twilight

    const Jrise = getSetJ(h0, phi, dec, lw, n, M, L) - (getSetJ(h0, phi, dec, lw, n, M, L) - Jnoon);
    const Jset = Jnoon + (Jnoon - Jrise);

    const Jcdawn = getSetJ(hc, phi, dec, lw, n, M, L) - (getSetJ(hc, phi, dec, lw, n, M, L) - Jnoon);
    const Jcdusk = Jnoon + (Jnoon - Jcdawn);

    return {
      sunrise: fromJulian(Jrise),
      sunset: fromJulian(Jset),
      civilDawn: fromJulian(Jcdawn),
      civilDusk: fromJulian(Jcdusk),
    };
  }catch(e){
    console.warn('Sun calculation failed', e);
    return { sunrise:null, sunset:null, civilDawn:null, civilDusk:null };
  }
}

// Very small lunar illumination & rough rise/set estimation
// Illumination: from simplified phase angle
export function computeMoonInfo(date, lat=40.7128, lon=-74.0060){
  const d = toDays(date);
  // Moon mean longitude, anomaly, distance (simplified)
  const L = RAD*(218.316 + 13.176396*d);
  const M = RAD*(134.963 + 13.064993*d);
  const F = RAD*(93.272 + 13.229350*d);

  // Ecliptic longitude/latitude (approx)
  const l = L + RAD*6.289 * Math.sin(M);
  const b = RAD*5.128 * Math.sin(F);
  const dt = 385001 - 20905 * Math.cos(M);

  // Sun ecliptic longitude for phase
  const Ms = solarMeanAnomaly(d);
  const Ls = eclipticLongitude(Ms);

  // Phase angle & illumination
  const phi = Math.acos(Math.sin(0)*Math.sin(b) + Math.cos(0)*Math.cos(b)*Math.cos(l - Ls));
  const k = (1 + Math.cos(phi)) / 2; // fraction
  const illum = Math.round(k*1000)/10;

  // Rough rise/set finder: scan hours for altitude 0 crossing
  let rise = null, set = null;
  try {
    for (let h=0; h<24; h++){
      const t = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), h));
      const d2 = toDays(t);
      const lw = RAD * -lon;
      const phiLat = RAD * lat;
      // Moon RA/DEC (approx)
      const ra = rightAscension(l, b);
      const dec = declination(l, b);
      const H = siderealTime(d2, lw) - ra;
      const alt = altitude(H, phiLat, dec);
      // Next hour
      const tNext = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), h+1));
      const d3 = toDays(tNext);
      const H2 = siderealTime(d3, lw) - ra;
      const alt2 = altitude(H2, phiLat, dec);
      if (alt<=0 && alt2>0 && !rise) rise = new Date(t.getTime()+ (0 - alt)/(alt2-alt)*3600*1000);
      if (alt>0 && alt2<=0 && !set) set = new Date(t.getTime()+ (0 - alt)/(alt2-alt)*3600*1000);
      if (rise && set) break;
    }
  } catch(e){ /* keep nulls */ }
  return { rise, set, illuminationPct: illum };
}
`,
  mapGoogle: `// /public/map-google.js
import { loadGoogle, hasGoogle } from './lib/googleLoader.js';

let gmap = null;
let overlays = { markers: [], arrows: [], route: null };
let editMode = false;

export function isReady(){ return !!gmap; }

export async function initGoogleMap(key, containerId='map-google') {
  const container = document.getElementById(containerId);
  if (!container) throw new Error('Missing Google map container');
  const google = await loadGoogle(key);
  gmap = new google.maps.Map(container, {
    center: { lat: 40.7128, lng: -74.0060 },
    zoom: 12,
    mapTypeControl: false,
    streetViewControl: false,
    fullscreenControl: true,
    clickableIcons: false,
  });
  clear();
  return gmap;
}

export function setEditMode(on){
  editMode = !!on;
  // Make existing markers draggable accordingly
  overlays.markers.forEach(m => m.setDraggable(editMode));
}

function clear(){
  if (!hasGoogle() || !gmap) return;
  overlays.markers.forEach(m => m.setMap(null));
  overlays.arrows.forEach(p => p.setMap(null));
  overlays.markers = []; overlays.arrows = [];
  if (overlays.route){ overlays.route.setMap(null); overlays.route = null; }
}

export function teardown(){
  clear();
  gmap = null;
}

export function renderMarkers(google, visibleLocations, onAnchorMoved){
  clear();
  const bounds = new google.maps.LatLngBounds();
  visibleLocations.forEach(loc => {
    // Anchor marker
    const a = loc.anchors[loc.activeAnchor ?? 0];
    const pos = new google.maps.LatLng(a.lat, a.lon);
    const marker = new google.maps.Marker({
      position: pos,
      map: gmap,
      title: loc.name,
      draggable: !!editMode,
      icon: {
        path: google.maps.SymbolPath.CIRCLE,
        scale: 6,
        fillColor: colorForBlock(loc.block),
        fillOpacity: 1, strokeColor: '#111', strokeWeight: 1
      }
    });
    marker.addListener('dragend', (ev)=>{
      a.lat = ev.latLng.lat();
      a.lon = ev.latLng.lng();
      onAnchorMoved && onAnchorMoved(loc.id, a.lat, a.lon);
    });
    overlays.markers.push(marker);
    bounds.extend(pos);

    // Micro-pin markers & arrows
    (loc.__microAbs || []).forEach(mp => {
      const mm = new google.maps.Marker({
        position: { lat: mp.lat, lng: mp.lon },
        map: gmap,
        title: mp.title,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 4,
          fillColor: '#00bfb3',
          fillOpacity: 1, strokeColor: '#004f4a', strokeWeight: 1
        }
      });
      overlays.markers.push(mm);
      bounds.extend(mm.getPosition());

      // Subject arrow (short line in bearing direction)
      const line = new google.maps.Polyline({
        path: [
          { lat: mp.lat, lng: mp.lon },
          { lat: mp.lat2, lng: mp.lon2 }
        ],
        geodesic: true,
        strokeColor: '#00bfb3',
        strokeOpacity: 0.9,
        strokeWeight: 2,
        map: gmap
      });
      overlays.arrows.push(line);
    });
  });
  if (!bounds.isEmpty()) gmap.fitBounds(bounds, 60);
}

export function fitOne(google, loc){
  const bounds = new google.maps.LatLngBounds();
  const a = loc.anchors[loc.activeAnchor ?? 0];
  bounds.extend(new google.maps.LatLng(a.lat, a.lon));
  (loc.__microAbs || []).forEach(mp => {
    bounds.extend(new google.maps.LatLng(mp.lat, mp.lon));
  });
  if (!bounds.isEmpty()) gmap.fitBounds(bounds, 80);
}

export async function distanceAndRoute(google, origin, destLatLng, draw=true){
  return new Promise((resolve, reject)=>{
    const dm = new google.maps.DistanceMatrixService();
    dm.getDistanceMatrix({
      origins: [origin],
      destinations: [destLatLng],
      travelMode: google.maps.TravelMode.WALKING,
      unitSystem: google.maps.UnitSystem.IMPERIAL
    }, (res, status)=>{
      if (status !== 'OK' || !res.rows?.[0]?.elements?.[0]) {
        return reject(new Error('Distance matrix failed'));
      }
      const el = res.rows[0].elements[0];
      if (!draw) return resolve(el);
      const dir = new google.maps.DirectionsService();
      const ren = new google.maps.DirectionsRenderer({ suppressMarkers:true, preserveViewport:true });
      dir.route({
        origin, destination: destLatLng, travelMode: google.maps.TravelMode.WALKING
      }, (routeRes, s2)=>{
        if (s2 !== 'OK') return reject(new Error('Directions failed'));
        if (overlays.route) overlays.route.setMap(null);
        ren.setMap(gmap);
        ren.setDirections(routeRes);
        overlays.route = ren;
        resolve(el);
      });
    });
  });
}

function colorForBlock(b){
  switch(b){
    case 'Morning': return '#22c55e';
    case 'Afternoon': return '#f59e0b';
    case 'Evening': return '#3b82f6';
    case 'Night': return '#a855f7';
    default: return '#9ca3af';
  }
}

export const _internal = { clear, colorForBlock };
`,
  mapLeaflet: `// /public/map-leaflet.js
let Lmod = null;
let lmap = null;
let layers = [];

async function ensureLeaflet(){
  if (Lmod) return Lmod;
  // Load ESM build from unpkg
  const css = document.createElement('link');
  css.rel = 'stylesheet';
  css.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
  document.head.appendChild(css);
  Lmod = await import('https://unpkg.com/leaflet@1.9.4/dist/leaflet-src.esm.js');
  return Lmod;
}

export async function initLeaflet(containerId='map-leaflet'){
  const L = await ensureLeaflet();
  const el = document.getElementById(containerId);
  lmap = L.map(el, { zoomControl: true, attributionControl: true }).setView([40.7128,-74.0060], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap'
  }).addTo(lmap);
  clear();
  return lmap;
}

export function teardown(){
  if (!lmap) return;
  lmap.remove();
  lmap = null;
  layers = [];
}

export function renderMarkers(visibleLocations){
  if (!lmap) return;
  clear();
  const L = Lmod;
  const bounds = [];
  visibleLocations.forEach(loc => {
    const a = loc.anchors[loc.activeAnchor ?? 0];
    const anchor = L.circleMarker([a.lat, a.lon], {radius:6,color:'#111',fillColor:colorForBlock(loc.block),fillOpacity:1,weight:1});
    anchor.addTo(lmap); layers.push(anchor);
    bounds.push([a.lat, a.lon]);
    (loc.__microAbs || []).forEach(mp => {
      const m = L.circleMarker([mp.lat, mp.lon], {radius:4,color:'#004f4a',fillColor:'#00bfb3',fillOpacity:1,weight:1});
      m.addTo(lmap); layers.push(m);
      bounds.push([mp.lat, mp.lon]);
      // Arrow
      const line = L.polyline([[mp.lat, mp.lon],[mp.lat2, mp.lon2]], {color:'#00bfb3',weight:2,opacity:.9});
      line.addTo(lmap); layers.push(line);
    });
  });
  if (bounds.length) lmap.fitBounds(bounds, { padding: [60,60] });
}

export function fitOne(loc){
  const bounds = [];
  const a = loc.anchors[loc.activeAnchor ?? 0];
  bounds.push([a.lat, a.lon]);
  (loc.__microAbs || []).forEach(mp => bounds.push([mp.lat, mp.lon]));
  if (bounds.length) lmap.fitBounds(bounds, { padding: [80,80] });
}

function clear(){
  layers.forEach(layer => { try { layer.remove(); } catch{} });
  layers = [];
}

function colorForBlock(b){
  switch(b){
    case 'Morning': return '#22c55e';
    case 'Afternoon': return '#f59e0b';
    case 'Evening': return '#3b82f6';
    case 'Night': return '#a855f7';
    default: return '#9ca3af';
  }
}

export const _internal = { clear };
`,
};

const urls = {}
urls['config'] = URL.createObjectURL(new Blob([SRC.config], {type:'text/javascript'}));
urls['data/locations'] = URL.createObjectURL(new Blob([SRC.locations], {type:'text/javascript'}));
urls['lib/googleLoader'] = URL.createObjectURL(new Blob([SRC.googleLoader], {type:'text/javascript'}));
urls['lib/sunmoon'] = URL.createObjectURL(new Blob([SRC.sunmoon], {type:'text/javascript'}));
urls['map-leaflet'] = URL.createObjectURL(new Blob([SRC.mapLeaflet], {type:'text/javascript'}));

let mg = SRC.mapGoogle
  .replaceAll("from './lib/googleLoader.js'", `from '${urls['lib/googleLoader']}'`)
  .replaceAll('from "./lib/googleLoader.js"', `from '${urls['lib/googleLoader']}'`)
  .replaceAll("from 'lib/googleLoader'", `from '${urls['lib/googleLoader']}'`)
  .replaceAll('from "lib/googleLoader"', `from '${urls['lib/googleLoader']}'`);
urls['map-google'] = URL.createObjectURL(new Blob([mg], {type:'text/javascript'}));

let appSrc = SRC.app
  .replaceAll("from './data/locations.js'", `from '${urls['data/locations']}'`)
  .replaceAll('from "./data/locations.js"', `from '${urls['data/locations']}'`)
  .replaceAll("from 'data/locations'", `from '${urls['data/locations']}'`)
  .replaceAll('from "data/locations"', `from '${urls['data/locations']}'`)
  .replaceAll("from './config.js'", `from '${urls['config']}'`)
  .replaceAll('from "./config.js"', `from '${urls['config']}'`)
  .replaceAll("from 'config'", `from '${urls['config']}'`)
  .replaceAll('from "config"', `from '${urls['config']}'`)
  .replaceAll("from './lib/sunmoon.js'", `from '${urls['lib/sunmoon']}'`)
  .replaceAll('from "./lib/sunmoon.js"', `from '${urls['lib/sunmoon']}'`)
  .replaceAll("from 'lib/sunmoon'", `from '${urls['lib/sunmoon']}'`)
  .replaceAll('from "lib/sunmoon"', `from '${urls['lib/sunmoon']}'`)
  .replaceAll("from './lib/googleLoader.js'", `from '${urls['lib/googleLoader']}'`)
  .replaceAll('from "./lib/googleLoader.js"', `from '${urls['lib/googleLoader']}'`)
  .replaceAll("from 'lib/googleLoader'", `from '${urls['lib/googleLoader']}'`)
  .replaceAll('from "lib/googleLoader"', `from '${urls['lib/googleLoader']}'`)
  .replaceAll("from './map-google.js'", `from '${urls['map-google']}'`)
  .replaceAll('from "./map-google.js"', `from '${urls['map-google']}'`)
  .replaceAll("from 'map-google'", `from '${urls['map-google']}'`)
  .replaceAll('from "map-google"', `from '${urls['map-google']}'`)
  .replaceAll("from './map-leaflet.js'", `from '${urls['map-leaflet']}'`)
  .replaceAll('from "./map-leaflet.js"', `from '${urls['map-leaflet']}'`)
  .replaceAll("from 'map-leaflet'", `from '${urls['map-leaflet']}'`)
  .replaceAll('from "map-leaflet"', `from '${urls['map-leaflet']}'`);

const appUrl = URL.createObjectURL(new Blob([appSrc], {type:'text/javascript'}));
import(appUrl);
</script>
</body>
</html>
